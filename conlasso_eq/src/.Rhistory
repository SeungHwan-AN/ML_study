t(Aeq)
idx1 = which(abs((-t(X) %*% y + rho_min * one_p) - t(Aeq) %*% lambda) <= 1e-4)
idx2 = which(abs((-t(X) %*% y - rho_min * one_p) - t(Aeq) %*% lambda) <= 1e-4)
activeset = union(idx1, idx2)
sort(activeset)
# plot
l1 = seq(-100, 200, length.out = 1000)
l2 = seq(-100, 200, length.out = 1000)
# rho_min = rho_min - 100
y_plus = function(l1, i) (-t(X) %*% y + rho_min * one_p)[i, ] / t(Aeq)[i ,2] - (l1 * t(Aeq)[i ,1]) / t(Aeq)[i ,2]
y_minus = function(l1, i) (-t(X) %*% y - rho_min * one_p)[i, ] / t(Aeq)[i ,2] - (l1 * t(Aeq)[i ,1]) / t(Aeq)[i ,2]
plot(l1, l2, ylab = "", type = "n", col = 1)
points(lambda[1, ], lambda[2, ], col = p+1)
for(i in 1:p) lines(l1, y_plus(l1, i), ylab = "", col = i)
for(i in 1:p) lines(l1, y_minus(l1, i), ylab = "", col = i)
rm(list = ls())
gc()
#
setwd("C:/Users/dpelt/OneDrive - 서울시립대학교/Documents/GitHub/ML_study/classo")
source("classopath_init.R")
source("classopath3.R")
if(!require("CVXR")) install.packages("CVXR")
library("CVXR")
#
set.seed(520)
# setting
n = 500
p = 20
m = 7
# data
X = matrix(rnorm(n*p), nrow = n)
X.m = apply(X, 2, mean)
X.m = matrix(X.m, nrow = n, ncol = p, byrow = T)
X = X - X.m
true_b = rep(1, p)
y = X %*% true_b + rnorm(n)
y = y - mean(y)
n = dim(X)[1]
p = dim(X)[2]
### equality constraints
# default
# Aeq = matrix(0, nrow = 0, ncol = dim(X)[2])
# beq = rep(0, dim(Aeq)[1])
# use
# Aeq = matrix(sample(seq(-1, 1, by = 1), m * p, replace = T), nrow = m)
# Aeq = matrix(sample(c(1,2,0), m * p, replace = T), nrow = m)
Aeq = matrix(rnorm(m*p, 0, 1), nrow = m)
# Aeq = matrix(c(1,1,1,0,0,0,1,1,1,0,
# -1,-1,-1,0,0,0,-1,-1,-1,0,
# 0,0,0,0,0,2,2,2,2,2), nrow = m, byrow = T)
# 0,0,0,0,0,-1,-1,-1,-1,-1,
# 1,1,1,1,1,1,1,1,1,1,
# 0,0,1,2,1,2,1,0,0,2,
# 0,0,2,4,2,4,2,0,0,4), nrow = m, byrow = T)
beq = matrix(rep(0, m), nrow = m)
### inequality constraints
# default
Aineq = matrix(0, nrow = 0, ncol = dim(X)[2])
bineq = rep(0, dim(Aineq)[1])
# use
# Aineq = -diag(rep(1, p))
# bineq = rep(0, p)
# penalty weight
penwt = rep(1, p) # 20-element Array{Frhoat64,1}
penidx = rep(T, p)
choose_one = F
# alrhocate variables arhong path
neq = dim(Aeq)[1]
nineq = dim(Aineq)[1]
maxiters = 5 * (p + nineq) # max number of path segments to consider
beta_path = matrix(rep(0, p * maxiters), nrow = p)
lambda_patheq = matrix(rep(0, neq * maxiters), nrow = neq) # dual variables for equality
mu_pathineq = matrix(rep(0, nineq * maxiters), nrow = nineq) # dual variables for inequality
rho_path = rep(0, maxiters) # tuning parameter
df_path = rep(Inf, maxiters) # degree of freedom
objval_path = rep(0, maxiters) # objective value
violation_path = rep(Inf, maxiters)
### initialization
H = t(X) %*% X
# find the maximum ρ (starting value)
l = init_path(X, y, Aeq, beq) # no inequality constraints
rho_path[1] = l$rho_max
lambda_patheq[, 1] = l$lambda_max
l
rm(list = ls())
gc()
#
setwd("C:/Users/dpelt/OneDrive - 서울시립대학교/Documents/GitHub/ML_study/classo")
source("classopath_init.R")
source("classopath3.R")
if(!require("CVXR")) install.packages("CVXR")
library("CVXR")
#
set.seed(520)
# setting
n = 100
p = 10
m = 5
# data
X = matrix(rnorm(n*p), nrow = n)
X.m = apply(X, 2, mean)
X.m = matrix(X.m, nrow = n, ncol = p, byrow = T)
X = X - X.m
true_b = rep(1, p)
y = X %*% true_b + rnorm(n)
y = y - mean(y)
n = dim(X)[1]
p = dim(X)[2]
### equality constraints
# default
# Aeq = matrix(0, nrow = 0, ncol = dim(X)[2])
# beq = rep(0, dim(Aeq)[1])
# use
# Aeq = matrix(sample(seq(-1, 1, by = 1), m * p, replace = T), nrow = m)
# Aeq = matrix(sample(c(1,2,0), m * p, replace = T), nrow = m)
Aeq = matrix(rnorm(m*p, 0, 1), nrow = m)
# Aeq = matrix(c(1,1,1,0,0,0,1,1,1,0,
# -1,-1,-1,0,0,0,-1,-1,-1,0,
# 0,0,0,0,0,2,2,2,2,2), nrow = m, byrow = T)
# 0,0,0,0,0,-1,-1,-1,-1,-1,
# 1,1,1,1,1,1,1,1,1,1,
# 0,0,1,2,1,2,1,0,0,2,
# 0,0,2,4,2,4,2,0,0,4), nrow = m, byrow = T)
beq = matrix(rep(0, m), nrow = m)
### inequality constraints
# default
Aineq = matrix(0, nrow = 0, ncol = dim(X)[2])
bineq = rep(0, dim(Aineq)[1])
# use
# Aineq = -diag(rep(1, p))
# bineq = rep(0, p)
# penalty weight
penwt = rep(1, p) # 20-element Array{Frhoat64,1}
penidx = rep(T, p)
choose_one = F
# alrhocate variables arhong path
neq = dim(Aeq)[1]
nineq = dim(Aineq)[1]
maxiters = 5 * (p + nineq) # max number of path segments to consider
beta_path = matrix(rep(0, p * maxiters), nrow = p)
lambda_patheq = matrix(rep(0, neq * maxiters), nrow = neq) # dual variables for equality
mu_pathineq = matrix(rep(0, nineq * maxiters), nrow = nineq) # dual variables for inequality
rho_path = rep(0, maxiters) # tuning parameter
df_path = rep(Inf, maxiters) # degree of freedom
objval_path = rep(0, maxiters) # objective value
violation_path = rep(Inf, maxiters)
### initialization
H = t(X) %*% X
# find the maximum ρ (starting value)
l = init_path(X, y, Aeq, beq) # no inequality constraints
rho_path[1] = l$rho_max
lambda_patheq[, 1] = l$lambda_max
l
rm(list = ls())
gc()
#
setwd("C:/Users/dpelt/OneDrive - 서울시립대학교/Documents/GitHub/ML_study/classo")
source("conlasso_init.R")
#
set.seed(520)
# setting
n = 200
p = 20
m = 5
# data
X = matrix(rnorm(n*p), nrow = n)
X.m = apply(X, 2, mean)
X.m = matrix(X.m, nrow = n, ncol = p, byrow = T)
X = X - X.m
true_b = rep(1, p)
y = X %*% true_b + rnorm(n)
y = y - mean(y)
n = dim(X)[1]
p = dim(X)[2]
### equality constraints
# default
# Aeq = matrix(0, nrow = 0, ncol = dim(X)[2])
# beq = rep(0, dim(Aeq)[1])
Aeq = matrix(rnorm(m*p, 0, 1), nrow = m)
beq = matrix(rep(0, m), nrow = m)
### inequality constraints
# default
Aineq = matrix(0, nrow = 0, ncol = dim(X)[2])
bineq = rep(0, dim(Aineq)[1])
# use
# Aineq = -diag(rep(1, p))
# bineq = rep(0, p)
# penalty weight
penwt = rep(1, p) # 20-element Array{Frhoat64,1}
# alrhocate variables arhong path
neq = dim(Aeq)[1]
# nineq = dim(Aineq)[1]
maxiters = 5 * (p + nineq) # max number of path segments to consider
beta_path = matrix(rep(0, p * maxiters), nrow = p)
lambda_patheq = matrix(rep(0, neq * maxiters), nrow = neq) # dual variables for equality
# mu_pathineq = matrix(rep(0, nineq * maxiters), nrow = nineq) # dual variables for inequality
rho_path = rep(0, maxiters) # tuning parameter
# df_path = rep(Inf, maxiters) # degree of freedom
objval_path = rep(0, maxiters) # objective value
violation_path = rep(Inf, maxiters)
### initialization
H = t(X) %*% X
# find the maximum ρ (starting value)
l = init_path(X, y, Aeq, beq) # no inequality constraints
rho_path[1] = l$rho_max
lambda_patheq[, 1] = l$lambda_max
rm(list = ls())
gc()
#
setwd("C:/Users/dpelt/OneDrive - 서울시립대학교/Documents/GitHub/ML_study/conlasso_eq")
source("conlasso_init.R")
#
set.seed(520)
# setting
n = 200
p = 20
m = 5
# data
X = matrix(rnorm(n*p), nrow = n)
X.m = apply(X, 2, mean)
X.m = matrix(X.m, nrow = n, ncol = p, byrow = T)
X = X - X.m
true_b = rep(1, p)
y = X %*% true_b + rnorm(n)
y = y - mean(y)
n = dim(X)[1]
p = dim(X)[2]
### equality constraints
# default
# Aeq = matrix(0, nrow = 0, ncol = dim(X)[2])
# beq = rep(0, dim(Aeq)[1])
Aeq = matrix(rnorm(m*p, 0, 1), nrow = m)
beq = matrix(rep(0, m), nrow = m)
### inequality constraints
# default
Aineq = matrix(0, nrow = 0, ncol = dim(X)[2])
bineq = rep(0, dim(Aineq)[1])
# use
# Aineq = -diag(rep(1, p))
# bineq = rep(0, p)
# penalty weight
penwt = rep(1, p) # 20-element Array{Frhoat64,1}
# alrhocate variables arhong path
neq = dim(Aeq)[1]
# nineq = dim(Aineq)[1]
maxiters = 5 * (p + nineq) # max number of path segments to consider
beta_path = matrix(rep(0, p * maxiters), nrow = p)
lambda_patheq = matrix(rep(0, neq * maxiters), nrow = neq) # dual variables for equality
# mu_pathineq = matrix(rep(0, nineq * maxiters), nrow = nineq) # dual variables for inequality
rho_path = rep(0, maxiters) # tuning parameter
# df_path = rep(Inf, maxiters) # degree of freedom
objval_path = rep(0, maxiters) # objective value
violation_path = rep(Inf, maxiters)
### initialization
H = t(X) %*% X
# find the maximum ρ (starting value)
l = init_path(X, y, Aeq, beq) # no inequality constraints
rho_path[1] = l$rho_max
lambda_patheq[, 1] = l$lambda_max
rm(list = ls())
gc()
#
setwd("C:/Users/dpelt/OneDrive - 서울시립대학교/Documents/GitHub/ML_study/conlasso_eq/src")
source("conlasso_init.R")
#
set.seed(520)
# setting
n = 200
p = 20
m = 5
# data
X = matrix(rnorm(n*p), nrow = n)
X.m = apply(X, 2, mean)
X.m = matrix(X.m, nrow = n, ncol = p, byrow = T)
X = X - X.m
true_b = rep(1, p)
y = X %*% true_b + rnorm(n)
y = y - mean(y)
n = dim(X)[1]
p = dim(X)[2]
### equality constraints
# default
# Aeq = matrix(0, nrow = 0, ncol = dim(X)[2])
# beq = rep(0, dim(Aeq)[1])
Aeq = matrix(rnorm(m*p, 0, 1), nrow = m)
beq = matrix(rep(0, m), nrow = m)
### inequality constraints
# default
Aineq = matrix(0, nrow = 0, ncol = dim(X)[2])
bineq = rep(0, dim(Aineq)[1])
# use
# Aineq = -diag(rep(1, p))
# bineq = rep(0, p)
# penalty weight
penwt = rep(1, p) # 20-element Array{Frhoat64,1}
# alrhocate variables arhong path
neq = dim(Aeq)[1]
# nineq = dim(Aineq)[1]
maxiters = 5 * (p + nineq) # max number of path segments to consider
beta_path = matrix(rep(0, p * maxiters), nrow = p)
lambda_patheq = matrix(rep(0, neq * maxiters), nrow = neq) # dual variables for equality
# mu_pathineq = matrix(rep(0, nineq * maxiters), nrow = nineq) # dual variables for inequality
rho_path = rep(0, maxiters) # tuning parameter
# df_path = rep(Inf, maxiters) # degree of freedom
objval_path = rep(0, maxiters) # objective value
violation_path = rep(Inf, maxiters)
### initialization
H = t(X) %*% X
# find the maximum ρ (starting value)
l = init_path(X, y, Aeq, beq) # no inequality constraints
rho_path[1] = l$rho_max
lambda_patheq[, 1] = l$lambda_max
rm(list = ls())
gc()
#
setwd("C:/Users/dpelt/OneDrive - 서울시립대학교/Documents/GitHub/ML_study/conlasso_eq/src")
source("conlasso_init.R")
#
set.seed(520)
# setting
n = 200
p = 20
m = 5
# data
X = matrix(rnorm(n*p), nrow = n)
X.m = apply(X, 2, mean)
X.m = matrix(X.m, nrow = n, ncol = p, byrow = T)
X = X - X.m
true_b = rep(1, p)
y = X %*% true_b + rnorm(n)
y = y - mean(y)
n = dim(X)[1]
p = dim(X)[2]
### equality constraints
# default
# Aeq = matrix(0, nrow = 0, ncol = dim(X)[2])
# beq = rep(0, dim(Aeq)[1])
Aeq = matrix(rnorm(m*p, 0, 1), nrow = m)
beq = matrix(rep(0, m), nrow = m)
### inequality constraints
# default
Aineq = matrix(0, nrow = 0, ncol = dim(X)[2])
bineq = rep(0, dim(Aineq)[1])
# use
# Aineq = -diag(rep(1, p))
# bineq = rep(0, p)
# penalty weight
penwt = rep(1, p) # 20-element Array{Frhoat64,1}
# alrhocate variables arhong path
neq = dim(Aeq)[1]
# nineq = dim(Aineq)[1]
maxiters = 5 * p # max number of path segments to consider
beta_path = matrix(rep(0, p * maxiters), nrow = p)
lambda_patheq = matrix(rep(0, neq * maxiters), nrow = neq) # dual variables for equality
# mu_pathineq = matrix(rep(0, nineq * maxiters), nrow = nineq) # dual variables for inequality
rho_path = rep(0, maxiters) # tuning parameter
# df_path = rep(Inf, maxiters) # degree of freedom
objval_path = rep(0, maxiters) # objective value
violation_path = rep(Inf, maxiters)
### initialization
H = t(X) %*% X
# find the maximum ρ (starting value)
l = init_path(X, y, Aeq, beq) # no inequality constraints
rho_path[1] = l$rho_max
lambda_patheq[, 1] = l$lambda_max
#
# find the maximum ρ (starting value)
l = path_init(X, y, Aeq, beq) # no inequality constraints
rho_path[1] = l$rho_max
lambda_patheq[, 1] = l$lambda_max
#
length(l$activeset) == m + 1
H = t(X) %*% X
M = rbind(cbind(H[active_set, active_set], t(Aeq[, active_set])),
cbind(Aeq[, active_set], matrix(rep(0, m*m), nrow = m)))
# subgradient for init_beta = 0
beta_path[, 1] = 0
resid = y - X %*% beta_path[, 1]
subgrad = (- t(X) %*% resid - t(Aeq) %*% lambda_patheq[ ,1]) / rho_path[1]
# active set
active_set = rep(F, p)
active_set[l$activeset] = T
#
H = t(X) %*% X
M = rbind(cbind(H[active_set, active_set], t(Aeq[, active_set])),
cbind(Aeq[, active_set], matrix(rep(0, m*m), nrow = m)))
M
S = rbind(subgrad[active_set], rep(0, m))
subgrad[active_set]
S = rbind(subgrad[active_set, drop=F], rep(0, m))
subgrad[active_set, drop=F]
subgrad
S = rbind(subgrad[active_set, , drop=F], rep(0, m))
subgrad[active_set, , drop=F]
S = rbind(subgrad[active_set, , drop=F], matrix(rep(0, m), ncol = 1))
solve(M, S)
MASS::ginv(M) %*% S
eigen(M)$values
H = t(X) %*% X
M = rbind(cbind(H[active_set, active_set], t(Aeq[, active_set])),
cbind(Aeq[, active_set], matrix(rep(0, m*m), nrow = m)))
S = rbind(subgrad[active_set, , drop=F], matrix(rep(0, m), ncol = 1))
if(min(eigen(M)$values) > 0) {
b_m = solve(M, S)
}
b_m = MASS::ginv(M) %*% S
b_m
num_active = sum(active_set)
delta_b = b_m[1:num_active, ]
delta_b
delta_m = b_m[(num_active+1):nrow(b_m), ,drop=F]
delta_m
delta_b
delta_b = b_m[1:num_active, ,drop=F]
delta_b
# find delta_rho
delta_rho = rep(0, 3)
# find delta_rho
delta_rho = c()
# c1
delta = - beta_path[, k-1] / delta_b
# loop part -------------------------------------------------------
k = 2
# c1
delta = - beta_path[, k-1] / delta_b
beta_path[, k-1]
# c1
delta = - beta_path[, k-1, drop=F] / delta_b
delta_b
# c1
delta = - beta_path[active_set, k-1, drop=F] / delta_b
delta
# c1
delta = - beta_path[active_set, k-1] / delta_b
delta
delta_rho = c(delta_rho, delta)
delta_rho
t(Aeq) %*% delta_m
# c2: dual feasibility
t(Aeq) %*% delta_m
# c2: dual feasibility
t(Aeq) %*% delta_m <= t(X) %*% X[, active_set] %*% delta_b + 1
# c2: dual feasibility
t(Aeq) %*% delta_m <= t(X) %*% X[, active_set] %*% delta_b - 1
# c2: dual feasibility
t(Aeq) %*% lambda_patheq[, 1] <= -t(X) %*% (y - X[, active_set] %*% beta_path[, 1]) + rho_path[1]
(y - X[, active_set] %*% beta_path[, 1])
# c2: dual feasibility
t(Aeq) %*% lambda_patheq[, 1] <= -t(X) %*% (y - X[, active_set] %*% beta_path[active_set, 1]) + rho_path[1]
t(Aeq) %*% delta_m <= t(X) %*% X[, active_set] %*% delta_b - 1
t(Aeq) %*% delta_m >= t(X) %*% X[, active_set] %*% delta_b + 1
# c2: dual feasibility
viol_idx1 = t(Aeq) %*% delta_m <= t(X) %*% X[, active_set] %*% delta_b - 1
viol_idx2 = t(Aeq) %*% delta_m >= t(X) %*% X[, active_set] %*% delta_b + 1
viol_idx = c(viol_idx1, viol_idx2)
viol_id
viol_idx
viol_idx = which(c(viol_idx1, viol_idx2))
viol_idx
active_set
viol_idx = viol_idx1 | viol_idx2
viol_idx
# c2: dual feasibility
viol_idx1 = t(Aeq) %*% delta_m > t(X) %*% X[, active_set] %*% delta_b - 1
viol_idx2 = t(Aeq) %*% delta_m < t(X) %*% X[, active_set] %*% delta_b + 1
viol_idx = viol_idx1 | viol_idx2
viol_idx
# c2: dual feasibility
viol_idx1 = -t(Aeq) %*% delta_m > t(X) %*% X[, active_set] %*% delta_b - 1
viol_idx2 = -t(Aeq) %*% delta_m < t(X) %*% X[, active_set] %*% delta_b + 1
viol_idx = viol_idx1 | viol_idx2
viol_idx
# c2: dual feasibility
viol_idx1 = -t(Aeq) %*% delta_m > -t(X) %*% X[, active_set] %*% delta_b - 1
viol_idx2 = -t(Aeq) %*% delta_m < -t(X) %*% X[, active_set] %*% delta_b + 1
viol_idx = viol_idx1 | viol_idx2
viol_idx
# c2: dual feasibility
viol_idx1 = t(Aeq) %*% delta_m > t(X) %*% X[, active_set] %*% delta_b - 1
viol_idx2 = t(Aeq) %*% delta_m < t(X) %*% X[, active_set] %*% delta_b + 1
viol_idx = viol_idx1 | viol_idx2
viol_idx
viol_idx1
viol_idx2
# c1: active -> inactive
delta = beta_path[active_set, k-1, drop=F] / delta_b
delta_rho = c(delta_rho, delta)
# c2: dual feasibility
viol_idx1 = -t(Aeq) %*% delta_m > -t(X) %*% X[, active_set] %*% delta_b - 1
viol_idx2 = -t(Aeq) %*% delta_m < -t(X) %*% X[, active_set] %*% delta_b + 1
viol_idx = viol_idx1 | viol_idx2
viol_idx
# c2: dual feasibility
delta_b_total = rep(0, p)
delta_b_total[active_set] = delta_b
delta_b_tota
delta_b_total
active_set
viol_idx1 = -t(Aeq) %*% delta_m > -t(X) %*% X %*% delta_b_total - 1
viol_idx2 = -t(Aeq) %*% delta_m < -t(X) %*% X %*% delta_b_total + 1
viol_idx = viol_idx1 | viol_idx2
viol_idx
# c2: dual feasibility
delta_b_total = beta_path[, k-1]
delta_b_total[active_set] = delta_b_total[active_set] - delta_b
# c2: dual feasibility
delta_b_total = rep(0, p)
delta_b_total[active_set] = -delta_b
viol_idx1 = -t(Aeq) %*% delta_m > -t(X) %*% X %*% delta_b_total - 1
viol_idx2 = -t(Aeq) %*% delta_m < -t(X) %*% X %*% delta_b_total + 1
viol_idx = viol_idx1 | viol_idx2
viol_idx
