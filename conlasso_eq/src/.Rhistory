- t(Aeq[, idx]) %*% (lambda_patheq[, k-1] - delta * delta_m)) < (rho_path[1] - delta),
delta >= 0)
objective = Maximize(delta)
problem = Problem(objective, constraints)
result = solve(problem)
delta_rho = min(delta_rho, result$value)
}
if(abs(subgrad[active_set, ][j] + 1) < 1e-4) {
delta = Variable(1)
constraints = list((-t(X[, idx]) %*% (y - X[, idx] %*% (beta_path[idx, k-1] - delta * delta_b[j]))
- t(Aeq[, idx]) %*% (lambda_patheq[, k-1] - delta * delta_m)) > -(rho_path[1] - delta),
delta >= 0)
objective = Maximize(delta)
problem = Problem(objective, constraints)
result = solve(problem)
delta_rho = min(delta_rho, result$value)
}
}
delta_rho_vec = c(delta_rho_vec, delta_rho)
delta_rho_vec
# pick one delta_rho
which(0 < delta_rho_vec < 1)
# pick one delta_rho
delta_rho_vec[which(0 < delta_rho_vec)]
# pick one delta_rho
min(delta_rho_vec[which(0 < delta_rho_vec)])
# 3. dual feasibility + stationarity condition
active_set
# 3. dual feasibility + stationarity condition
delta = Variable(1)
constraints = list(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta * delta_m) <=
-t(X[, !active_set]) %*% (y - X[, !active_set] %*% (beta_path[active_set, k-1] - delta * delta_b)) +
(rho_path[k-1] - delta) * matrix(rep(0, sum(!active_set)), ncol = 1),
t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta * delta_m) >=
-t(X[, !active_set]) %*% (y - X[, !active_set] %*% (beta_path[active_set, k-1] - delta * delta_b)) -
(rho_path[k-1] - delta) * matrix(rep(0, sum(!active_set)), ncol = 1),
delta >= 0)
# 3. dual feasibility + stationarity condition
delta = Variable(1)
constraints = list(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta * delta_m) <=
-t(X[, !active_set]) %*% (y - X[, !active_set] %*% (beta_path[active_set, k-1] - delta * delta_b)) +
(rho_path[k-1] - delta) * matrix(rep(1, sum(!active_set)), ncol = 1),
t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta * delta_m) >=
-t(X[, !active_set]) %*% (y - X[, !active_set] %*% (beta_path[active_set, k-1] - delta * delta_b)) -
(rho_path[k-1] - delta) * matrix(rep(1, sum(!active_set)), ncol = 1),
delta >= 0)
delta = 1
t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta * delta_m) <=
-t(X[, !active_set]) %*% (y - X[, !active_set] %*% (beta_path[active_set, k-1] - delta * delta_b)) +
(rho_path[k-1] - delta) * matrix(rep(1, sum(!active_set)), ncol = 1)
t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta * delta_m)
t(X[, !active_set]) %*% (y - X[, !active_set] %*% (beta_path[active_set, k-1] - delta * delta_b))
# 3. dual feasibility + stationarity condition
delta = Variable(1)
constraints = list(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta * delta_m) <=
-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta * delta_b)) +
(rho_path[k-1] - delta) * matrix(rep(1, sum(!active_set)), ncol = 1),
t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta * delta_m) >=
-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta * delta_b)) -
(rho_path[k-1] - delta) * matrix(rep(1, sum(!active_set)), ncol = 1),
delta >= 0)
objective = Minimize(delta)
problem = Problem(objective, constraints)
result = solve(problem)
result = solve(problem)
delta_rho = min(delta_rho, result$value)
result$value
# solve
delta_rho = Inf
for(j in 1:num_active) {
idx = which(active_set)[j]
if(abs(subgrad[active_set, ][j] - 1) < 1e-4) {
delta = Variable(1)
constraints = list((-t(X[, idx]) %*% (y - X[, idx] %*% (beta_path[idx, k-1] - delta * delta_b[j]))
- t(Aeq[, idx]) %*% (lambda_patheq[, k-1] - delta * delta_m)) < (rho_path[1] - delta),
delta >= 0)
objective = Maximize(delta)
problem = Problem(objective, constraints)
result = solve(problem)
delta_rho = min(delta_rho, result$value)
}
if(abs(subgrad[active_set, ][j] + 1) < 1e-4) {
delta = Variable(1)
constraints = list((-t(X[, idx]) %*% (y - X[, idx] %*% (beta_path[idx, k-1] - delta * delta_b[j]))
- t(Aeq[, idx]) %*% (lambda_patheq[, k-1] - delta * delta_m)) > -(rho_path[1] - delta),
delta >= 0)
objective = Maximize(delta)
problem = Problem(objective, constraints)
result = solve(problem)
delta_rho = min(delta_rho, result$value)
}
}
delta_rho_vec = c(delta_rho_vec, delta_rho)
# 3. dual feasibility + stationarity condition
delta = Variable(1)
constraints = list(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta * delta_m) <=
-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta * delta_b)) +
(rho_path[k-1] - delta) * matrix(rep(1, sum(!active_set)), ncol = 1),
t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta * delta_m) >=
-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta * delta_b)) -
(rho_path[k-1] - delta) * matrix(rep(1, sum(!active_set)), ncol = 1),
delta >= 0)
objective = Minimize(delta)
problem = Problem(objective, constraints)
result = solve(problem)
delta_rho = min(delta_rho, result$value)
delta_rho
delta_rho_vec
# find delta_rho
delta_rho_vec = c()
# 1. active -> inactive
delta_rho = min(beta_path[active_set, 1] / delta_b)
delta_rho_vec = c(delta_rho_vec, delta_rho)
# 2. subgradient
subgrad[active_set, ]
next_subgrad = (-t(X[, active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1])))
# solve
delta_rho = Inf
for(j in 1:num_active) {
idx = which(active_set)[j]
if(abs(subgrad[active_set, ][j] - 1) < 1e-4) {
delta = Variable(1)
constraints = list((-t(X[, idx]) %*% (y - X[, idx] %*% (beta_path[idx, k-1] - delta * delta_b[j]))
- t(Aeq[, idx]) %*% (lambda_patheq[, k-1] - delta * delta_m)) < (rho_path[1] - delta),
delta >= 0)
objective = Maximize(delta)
problem = Problem(objective, constraints)
result = solve(problem)
delta_rho = min(delta_rho, result$value)
}
if(abs(subgrad[active_set, ][j] + 1) < 1e-4) {
delta = Variable(1)
constraints = list((-t(X[, idx]) %*% (y - X[, idx] %*% (beta_path[idx, k-1] - delta * delta_b[j]))
- t(Aeq[, idx]) %*% (lambda_patheq[, k-1] - delta * delta_m)) > -(rho_path[1] - delta),
delta >= 0)
objective = Maximize(delta)
problem = Problem(objective, constraints)
result = solve(problem)
delta_rho = min(delta_rho, result$value)
}
}
delta_rho_vec = c(delta_rho_vec, delta_rho)
# 3. dual feasibility + stationarity condition
delta = Variable(1)
constraints = list(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta * delta_m) <=
-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta * delta_b)) +
(rho_path[k-1] - delta) * matrix(rep(1, sum(!active_set)), ncol = 1),
t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta * delta_m) >=
-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta * delta_b)) -
(rho_path[k-1] - delta) * matrix(rep(1, sum(!active_set)), ncol = 1),
delta >= 0)
objective = Minimize(delta)
problem = Problem(objective, constraints)
result = solve(problem)
delta_rho_vec = c(delta_rho_vec, result$value)
delta_rho_vec
# pick one delta_rho
min(delta_rho_vec[which(0 < delta_rho_vec)])
delta_rho = result$value
t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta * delta_m) -
(-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta * delta_b)) +
(rho_path[k-1] - delta) * matrix(rep(1, sum(!active_set)), ncol = 1))
delta_rho = result$value
t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta_rho * delta_m) -
(-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta_rho * delta_b)) +
(rho_path[k-1] - delta_rho) * matrix(rep(1, sum(!active_set)), ncol = 1))
t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta_rho * delta_m) -
(-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta_rho * delta_b)) -
(rho_path[k-1] - delta_rho) * matrix(rep(1, sum(!active_set)), ncol = 1))
# 3. dual feasibility + stationarity condition
delta = Variable(1)
constraints = list(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta * delta_m) <=
-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta * delta_b)) +
(rho_path[k-1] - delta) * matrix(rep(1, sum(!active_set)), ncol = 1),
t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta * delta_m) >=
-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta * delta_b)) -
(rho_path[k-1] - delta) * matrix(rep(1, sum(!active_set)), ncol = 1),
delta >= 0)
objective = Maximize(delta)
problem = Problem(objective, constraints)
result = solve(problem)
delta_rho = result$value
delta_rho
t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta_rho * delta_m) -
(-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta_rho * delta_b)) +
(rho_path[k-1] - delta_rho) * matrix(rep(1, sum(!active_set)), ncol = 1))
t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta_rho * delta_m) -
(-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta_rho * delta_b)) -
(rho_path[k-1] - delta_rho) * matrix(rep(1, sum(!active_set)), ncol = 1))
which(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta_rho * delta_m) -
(-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta_rho * delta_b)) +
(rho_path[k-1] - delta_rho) * matrix(rep(1, sum(!active_set)), ncol = 1)) <= 1e-4)
which(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta_rho * delta_m) -
(-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta_rho * delta_b)) +
(rho_path[k-1] - delta_rho) * matrix(rep(1, sum(!active_set)), ncol = 1)) <= 1e-4)
which(abs(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta_rho * delta_m) -
(-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta_rho * delta_b)) +
(rho_path[k-1] - delta_rho) * matrix(rep(1, sum(!active_set)), ncol = 1))) <= 1e-4)
which(abs(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta_rho * delta_m) -
(-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta_rho * delta_b)) -
(rho_path[k-1] - delta_rho) * matrix(rep(1, sum(!active_set)), ncol = 1))) <= 1e-4)
new_j1 = which(abs(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta_rho * delta_m) -
(-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta_rho * delta_b)) +
(rho_path[k-1] - delta_rho) * matrix(rep(1, sum(!active_set)), ncol = 1))) <= 1e-4)
new_j2 = which(abs(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta_rho * delta_m) -
(-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta_rho * delta_b)) -
(rho_path[k-1] - delta_rho) * matrix(rep(1, sum(!active_set)), ncol = 1))) <= 1e-4)
new_j1 = which(abs(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta_rho * delta_m) -
(-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta_rho * delta_b)) +
(rho_path[k-1] - delta_rho) * matrix(rep(1, sum(!active_set)), ncol = 1))) <= 1e-4)
new_j2 = which(abs(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta_rho * delta_m) -
(-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta_rho * delta_b)) -
(rho_path[k-1] - delta_rho) * matrix(rep(1, sum(!active_set)), ncol = 1))) <= 1e-4)
new_j = c(new_j1, new_j2)
new_j
new_j = union(new_j1, new_j2)
new_j
constraints = list(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta * delta_m) <=
-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta * delta_b)) +
(rho_path[k-1] - delta) * matrix(rep(1, sum(!active_set)), ncol = 1),
t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta * delta_m) >=
-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta * delta_b)) -
(rho_path[k-1] - delta) * matrix(rep(1, sum(!active_set)), ncol = 1),
delta >= 0)
objective = Minimize(delta)
problem = Problem(objective, constraints)
result = solve(problem)
delta_rho_vec = c(delta_rho_vec, result$value)
# predictor on boundary
delta_rho = result$value
new_j1 = which(abs(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta_rho * delta_m) -
(-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta_rho * delta_b)) +
(rho_path[k-1] - delta_rho) * matrix(rep(1, sum(!active_set)), ncol = 1))) <= 1e-4)
new_j2 = which(abs(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta_rho * delta_m) -
(-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta_rho * delta_b)) -
(rho_path[k-1] - delta_rho) * matrix(rep(1, sum(!active_set)), ncol = 1))) <= 1e-4)
new_j = union(new_j1, new_j2)
# 3. dual feasibility + stationarity condition
delta = Variable(1)
constraints = list(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta * delta_m) <=
-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta * delta_b)) +
(rho_path[k-1] - delta) * matrix(rep(1, sum(!active_set)), ncol = 1),
t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta * delta_m) >=
-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta * delta_b)) -
(rho_path[k-1] - delta) * matrix(rep(1, sum(!active_set)), ncol = 1),
delta >= 0)
objective = Maximize(delta)
problem = Problem(objective, constraints)
result = solve(problem)
delta_rho_vec = c(delta_rho_vec, result$value)
# predictor on boundary
delta_rho = result$value
new_j1 = which(abs(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta_rho * delta_m) -
(-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta_rho * delta_b)) +
(rho_path[k-1] - delta_rho) * matrix(rep(1, sum(!active_set)), ncol = 1))) <= 1e-4)
new_j2 = which(abs(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta_rho * delta_m) -
(-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta_rho * delta_b)) -
(rho_path[k-1] - delta_rho) * matrix(rep(1, sum(!active_set)), ncol = 1))) <= 1e-4)
new_j = union(new_j1, new_j2)
# pick one delta_rho
min(delta_rho_vec[which(0 < delta_rho_vec)])
# pick one delta_rho
delta_rho_vec
delta = 1
j = 1
abs(subgrad[active_set, ][j] + 1) < 1e-4
idx = which(active_set)[j]
(-t(X[, idx]) %*% (y - X[, idx] %*% (beta_path[idx, k-1] - delta * delta_b[j]))
- t(Aeq[, idx]) %*% (lambda_patheq[, k-1] - delta * delta_m)) > -(rho_path[1] - delta)
(-t(X[, idx]) %*% (y - X[, idx] %*% (beta_path[idx, k-1] - delta * delta_b[j]))
- t(Aeq[, idx]) %*% (lambda_patheq[, k-1] - delta * delta_m)) > -(rho_path[1] - delta)
-t(X[, idx]) %*% (y - X[, idx] %*% (beta_path[idx, k-1] - delta * delta_b[j]))
-t(X[, idx]) %*% (y - X[, idx] %*% (beta_path[idx, k-1] - delta * delta_b[j]))
(beta_path[idx, k-1] - delta * delta_b[j])
X[, idx] %*% (beta_path[idx, k-1] - delta * delta_b[j])
idx
X[, idx]
(y - X[, idx, drop=F] %*% (beta_path[idx, k-1] - delta * delta_b[j])
)
(-t(X[, idx]) %*% (y - X[, idx, drop=F] %*% (beta_path[idx, k-1] - delta * delta_b[j]))
- t(Aeq[, idx]) %*% (lambda_patheq[, k-1] - delta * delta_m)) > -(rho_path[1] - delta)
delta_rho = min(delta_rho_vec[which(0 < delta_rho_vec)])
delta_rho
# update
beta_path[active_set, k] = beta_path[active_set, k] - delta_rho * delta_b
beta_path[active_set, k]
lambda_patheq[, k] = lambda_patheq[, k-1] - delta_rho * delta_m
rho_path[k] = rho_path[k-1] - delta_rho
active_set
### loop part -------------------------------------------------------
k = 3
# find direction
H = t(X) %*% X
M = rbind(cbind(H[active_set, active_set], t(Aeq[, active_set])),
cbind(Aeq[, active_set], matrix(rep(0, m*m), nrow = m)))
S = rbind(subgrad[active_set, , drop=F], matrix(rep(0, m), ncol = 1))
b_m = MASS::ginv(M) %*% S
if(min(eigen(M)$values) > 0) {
b_m = solve(M, S)
}
delta_b = b_m[1:num_active, ,drop=F]
delta_m = b_m[(num_active+1):nrow(b_m), ,drop=F]
# find delta_rho
delta_rho_vec = c()
# 1. active -> inactive
delta_rho = min(beta_path[active_set, 1] / delta_b)
delta_rho_vec = c(delta_rho_vec, delta_rho)
# 2. subgradient
delta_rho = Inf
for(j in 1:num_active) {
idx = which(active_set)[j]
if(abs(subgrad[active_set, ][j] - 1) < 1e-4) {
delta = Variable(1)
constraints = list((-t(X[, idx]) %*% (y - X[, idx, drop=F] %*% (beta_path[idx, k-1] - delta * delta_b[j]))
- t(Aeq[, idx]) %*% (lambda_patheq[, k-1] - delta * delta_m)) < (rho_path[1] - delta),
delta >= 0)
objective = Maximize(delta)
problem = Problem(objective, constraints)
result = solve(problem)
delta_rho = min(delta_rho, result$value)
}
if(abs(subgrad[active_set, ][j] + 1) < 1e-4) {
delta = Variable(1)
constraints = list((-t(X[, idx]) %*% (y - X[, idx, drop=F] %*% (beta_path[idx, k-1] - delta * delta_b[j]))
- t(Aeq[, idx]) %*% (lambda_patheq[, k-1] - delta * delta_m)) > -(rho_path[1] - delta),
delta >= 0)
objective = Maximize(delta)
problem = Problem(objective, constraints)
result = solve(problem)
delta_rho = min(delta_rho, result$value)
}
}
delta_rho_vec = c(delta_rho_vec, delta_rho)
# 3. dual feasibility + stationarity condition
delta = Variable(1)
constraints = list(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta * delta_m) <=
-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta * delta_b)) +
(rho_path[k-1] - delta) * matrix(rep(1, sum(!active_set)), ncol = 1),
t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta * delta_m) >=
-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta * delta_b)) -
(rho_path[k-1] - delta) * matrix(rep(1, sum(!active_set)), ncol = 1),
delta >= 0)
objective = Maximize(delta)
problem = Problem(objective, constraints)
result = solve(problem)
delta_rho_vec = c(delta_rho_vec, result$value)
# predictor on boundary
delta_rho = result$value
new_j1 = which(abs(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta_rho * delta_m) -
(-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta_rho * delta_b)) +
(rho_path[k-1] - delta_rho) * matrix(rep(1, sum(!active_set)), ncol = 1))) <= 1e-4)
new_j2 = which(abs(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta_rho * delta_m) -
(-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta_rho * delta_b)) -
(rho_path[k-1] - delta_rho) * matrix(rep(1, sum(!active_set)), ncol = 1))) <= 1e-4)
new_j = union(new_j1, new_j2)
# pick one delta_rho
delta_rho_vec # 지나치게 작은 값은 빼면 안되나?
delta_rho = min(delta_rho_vec[which(0 < delta_rho_vec)])
# update
beta_path[active_set, k] = beta_path[active_set, k-1] - delta_rho * delta_b
lambda_patheq[, k] = lambda_patheq[, k-1] - delta_rho * delta_m
rho_path[k] = rho_path[k-1] - delta_rho
beta_path
k = 2
# find direction
H = t(X) %*% X
M = rbind(cbind(H[active_set, active_set], t(Aeq[, active_set])),
cbind(Aeq[, active_set], matrix(rep(0, m*m), nrow = m)))
S = rbind(subgrad[active_set, , drop=F], matrix(rep(0, m), ncol = 1))
b_m = MASS::ginv(M) %*% S
if(min(eigen(M)$values) > 0) {
b_m = solve(M, S)
}
delta_b = b_m[1:num_active, ,drop=F]
delta_m = b_m[(num_active+1):nrow(b_m), ,drop=F]
# find delta_rho
delta_rho_vec = c()
# 1. active -> inactive
delta_rho = min(beta_path[active_set, 1] / delta_b)
delta_rho_vec = c(delta_rho_vec, delta_rho)
# 2. subgradient
delta_rho = Inf
for(j in 1:num_active) {
idx = which(active_set)[j]
if(abs(subgrad[active_set, ][j] - 1) < 1e-4) {
delta = Variable(1)
constraints = list((-t(X[, idx]) %*% (y - X[, idx, drop=F] %*% (beta_path[idx, k-1] - delta * delta_b[j]))
- t(Aeq[, idx]) %*% (lambda_patheq[, k-1] - delta * delta_m)) < (rho_path[1] - delta),
delta >= 0)
objective = Maximize(delta)
problem = Problem(objective, constraints)
result = solve(problem)
delta_rho = min(delta_rho, result$value)
}
if(abs(subgrad[active_set, ][j] + 1) < 1e-4) {
delta = Variable(1)
constraints = list((-t(X[, idx]) %*% (y - X[, idx, drop=F] %*% (beta_path[idx, k-1] - delta * delta_b[j]))
- t(Aeq[, idx]) %*% (lambda_patheq[, k-1] - delta * delta_m)) > -(rho_path[1] - delta),
delta >= 0)
objective = Maximize(delta)
problem = Problem(objective, constraints)
result = solve(problem)
delta_rho = min(delta_rho, result$value)
}
}
delta_rho_vec = c(delta_rho_vec, delta_rho)
# 3. dual feasibility + stationarity condition
delta = Variable(1)
constraints = list(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta * delta_m) <=
-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta * delta_b)) +
(rho_path[k-1] - delta) * matrix(rep(1, sum(!active_set)), ncol = 1),
t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta * delta_m) >=
-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta * delta_b)) -
(rho_path[k-1] - delta) * matrix(rep(1, sum(!active_set)), ncol = 1),
delta >= 0)
objective = Maximize(delta)
problem = Problem(objective, constraints)
result = solve(problem)
delta_rho_vec = c(delta_rho_vec, result$value)
# predictor on boundary
delta_rho = result$value
new_j1 = which(abs(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta_rho * delta_m) -
(-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta_rho * delta_b)) +
(rho_path[k-1] - delta_rho) * matrix(rep(1, sum(!active_set)), ncol = 1))) <= 1e-4)
new_j2 = which(abs(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta_rho * delta_m) -
(-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta_rho * delta_b)) -
(rho_path[k-1] - delta_rho) * matrix(rep(1, sum(!active_set)), ncol = 1))) <= 1e-4)
new_j = union(new_j1, new_j2)
# pick one delta_rho
delta_rho_vec # 지나치게 작은 값은 빼면 안되나?
delta_rho = min(delta_rho_vec[which(0 < delta_rho_vec)])
# update
delta_rho = result$value
beta_path[active_set, k] = beta_path[active_set, k-1] - delta_rho * delta_b
lambda_patheq[, k] = lambda_patheq[, k-1] - delta_rho * delta_m
rho_path[k] = rho_path[k-1] - delta_rho
beta_path[active_set, k]
Aeq %*% beta_path[, k]
k = 3
# find direction
H = t(X) %*% X
M = rbind(cbind(H[active_set, active_set], t(Aeq[, active_set])),
cbind(Aeq[, active_set], matrix(rep(0, m*m), nrow = m)))
S = rbind(subgrad[active_set, , drop=F], matrix(rep(0, m), ncol = 1))
b_m = MASS::ginv(M) %*% S
if(min(eigen(M)$values) > 0) {
b_m = solve(M, S)
}
delta_b = b_m[1:num_active, ,drop=F]
delta_m = b_m[(num_active+1):nrow(b_m), ,drop=F]
# find delta_rho
delta_rho_vec = c()
# 1. active -> inactive
delta_rho = min(beta_path[active_set, 1] / delta_b)
delta_rho_vec = c(delta_rho_vec, delta_rho)
# 2. subgradient
delta_rho = Inf
for(j in 1:num_active) {
idx = which(active_set)[j]
if(abs(subgrad[active_set, ][j] - 1) < 1e-4) {
delta = Variable(1)
constraints = list((-t(X[, idx]) %*% (y - X[, idx, drop=F] %*% (beta_path[idx, k-1] - delta * delta_b[j]))
- t(Aeq[, idx]) %*% (lambda_patheq[, k-1] - delta * delta_m)) < (rho_path[1] - delta),
delta >= 0)
objective = Maximize(delta)
problem = Problem(objective, constraints)
result = solve(problem)
delta_rho = min(delta_rho, result$value)
}
if(abs(subgrad[active_set, ][j] + 1) < 1e-4) {
delta = Variable(1)
constraints = list((-t(X[, idx]) %*% (y - X[, idx, drop=F] %*% (beta_path[idx, k-1] - delta * delta_b[j]))
- t(Aeq[, idx]) %*% (lambda_patheq[, k-1] - delta * delta_m)) > -(rho_path[1] - delta),
delta >= 0)
objective = Maximize(delta)
problem = Problem(objective, constraints)
result = solve(problem)
delta_rho = min(delta_rho, result$value)
}
}
delta_rho_vec = c(delta_rho_vec, delta_rho)
# 3. dual feasibility + stationarity condition
delta = Variable(1)
constraints = list(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta * delta_m) <=
-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta * delta_b)) +
(rho_path[k-1] - delta) * matrix(rep(1, sum(!active_set)), ncol = 1),
t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta * delta_m) >=
-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta * delta_b)) -
(rho_path[k-1] - delta) * matrix(rep(1, sum(!active_set)), ncol = 1),
delta >= 0)
objective = Maximize(delta)
problem = Problem(objective, constraints)
result = solve(problem)
delta_rho_vec = c(delta_rho_vec, result$value)
# predictor on boundary
delta_rho = result$value
new_j1 = which(abs(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta_rho * delta_m) -
(-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta_rho * delta_b)) +
(rho_path[k-1] - delta_rho) * matrix(rep(1, sum(!active_set)), ncol = 1))) <= 1e-4)
new_j2 = which(abs(t(Aeq[, !active_set]) %*% (lambda_patheq[, 1] - delta_rho * delta_m) -
(-t(X[, !active_set]) %*% (y - X[, active_set] %*% (beta_path[active_set, k-1] - delta_rho * delta_b)) -
(rho_path[k-1] - delta_rho) * matrix(rep(1, sum(!active_set)), ncol = 1))) <= 1e-4)
new_j = union(new_j1, new_j2)
# pick one delta_rho
delta_rho_vec # 지나치게 작은 값은 빼면 안되나?
delta_rho = min(delta_rho_vec[which(0 < delta_rho_vec)])
# update
delta_rho = result$value
beta_path[active_set, k] = beta_path[active_set, k-1] - delta_rho * delta_b
lambda_patheq[, k] = lambda_patheq[, k-1] - delta_rho * delta_m
rho_path[k] = rho_path[k-1] - delta_rho
Aeq %*% beta_path[, k]
