idx2 = which(abs((-t(X) %*% y - rho_min * one_p) - t(Aeq) %*% lambda) <= 1e-4)
activeset = union(idx1, idx2)
sort(activeset)
# rho_min에서는 모든 부등조건을 만족
idx1 = which((-t(X) %*% y + rho_min * one_p) <= t(Aeq) %*% lambda)
idx2 = which((-t(X) %*% y - rho_min * one_p) >= t(Aeq) %*% lambda)
activeset = c(idx1, idx2)
sort(activeset)
### 2. violation check
# find new_lambda corresponding to decreased rho(아주 작게 감소된 rho에 대해 violation을 새로 체크)
new_rho = rho_min - 1e-4 # rho is decreasing direction
target = Variable(1 + m)
Amat1 = matrix(c(rep(0, m), 1), nrow = 1)
Amat = rbind(cbind(t(Aeq), one_p), cbind(-t(Aeq), one_p))
bmat = rbind(-t(X) %*% y + 2 * new_rho * one_p, t(X) %*% y + 2 * new_rho * one_p)
constraints = list(Amat %*% target <= bmat,
Amat1 %*% target <= new_rho)
objective = Maximize(Amat1 %*% target)
problem = Problem(objective, constraints)
result = solve(problem)
z = result$getValue(target)[m+1, ]
new_lambda = result$getValue(target)[1:m, , drop=F]
# 새로운 rho, lambda에 대해 부등조건을 만족하지 않는(범위를 벗어나는) predictor를 찾는다
idx1 = which((-t(X) %*% y + new_rho * one_p) <= t(Aeq) %*% new_lambda)
idx2 = which((-t(X) %*% y - new_rho * one_p) >= t(Aeq) %*% new_lambda)
activeset = c(idx1, idx2)
sort(activeset) # 최종 active set
rm(list=ls())
gc()
set.seed(520)
if(!require("CVXR")) install.packages("CVXR")
library("CVXR")
# setting
n = 200
p = 10
m = 5
# data
X = matrix(rnorm(n*p), nrow = n)
X.m = apply(X, 2, mean)
X.m = matrix(X.m, nrow = n, ncol = p, byrow = T)
X = X - X.m
true_b = rep(1, p)
y = X %*% true_b + rnorm(n)
y = y - mean(y)
# constraints
Aeq = matrix(sample(seq(-1, 2, by = 1), m * p, replace = T), nrow = m)
# Aeq = matrix(sample(c(-2, -1, 1, 2), m * p, replace = T), nrow = m)
# Aeq = matrix(c(1,1,0,
# -1,0,1,
# -1,-1,1), nrow = m, byrow = T)
beq = matrix(rep(0, m), nrow = m)
# setting
zero_p = matrix(rep(0, p), ncol = 1)
zero_m = matrix(rep(0, m), ncol = 1)
zero_pm = matrix(rep(0, p*m), nrow = p)
zero_pp = matrix(rep(0, p*p), nrow = p)
one_p = matrix(rep(1, p), ncol = 1)
one_m = matrix(rep(1, m), ncol = 1)
I_p = matrix(diag(rep(1, p)), nrow = p)
# design matrix for Constraints
Aeq1 = matrix(c(1, t(zero_p), t(zero_m)), nrow = 1)
Aeq2 = rbind(c(0, t(zero_p), t(zero_m)),
cbind(zero_p, I_p, zero_pm),
c(0, t(zero_p), t(zero_m)))
Aeq3 = rbind(c(0, t(zero_p), t(zero_m)),
cbind(zero_p, zero_pp, t(Aeq)),
c(0, t(zero_p), t(zero_m)))
Aeq4 = rbind(0, -t(X)%*%y, 0)
Aeq5 = rbind(c(0, t(zero_p), t(zero_m)),
cbind(one_p, zero_pp, zero_pm),
c(0, t(zero_p), t(zero_m)))
# solve
target = Variable(1 + p + m)
constraints = list(Aeq2 %*% target == Aeq3 %*% target,
Aeq2 %*% target <= Aeq4 + Aeq5 %*% target,
Aeq2 %*% target >= Aeq4 - Aeq5 %*% target,
Aeq1 %*% target >= 0)
objective = Minimize(Aeq1 %*% target)
problem = Problem(objective, constraints)
result = solve(problem)
# result
target = result$getValue(target)
rho_min = target[1, ]
z = target[2:(1+p), ,drop=F]
lambda = target[(p+2):nrow(target), ,drop=F]
rho_min; z; lambda
t(Aeq)
### 1. 이건 경계에 있는 predictor를 바로 activeset 지정 -> 이건 아닌듯!
idx1 = which(abs((-t(X) %*% y + rho_min * one_p) - t(Aeq) %*% lambda) <= 1e-4)
idx2 = which(abs((-t(X) %*% y - rho_min * one_p) - t(Aeq) %*% lambda) <= 1e-4)
activeset = union(idx1, idx2)
sort(activeset)
# rho_min에서는 모든 부등조건을 만족
idx1 = which((-t(X) %*% y + rho_min * one_p) <= t(Aeq) %*% lambda)
idx2 = which((-t(X) %*% y - rho_min * one_p) >= t(Aeq) %*% lambda)
activeset = c(idx1, idx2)
sort(activeset)
### 2. violation check
# find new_lambda corresponding to decreased rho(아주 작게 감소된 rho에 대해 violation을 새로 체크)
new_rho = rho_min - 1e-4 # rho is decreasing direction
target = Variable(1 + m)
Amat1 = matrix(c(rep(0, m), 1), nrow = 1)
Amat = rbind(cbind(t(Aeq), one_p), cbind(-t(Aeq), one_p))
bmat = rbind(-t(X) %*% y + 2 * new_rho * one_p, t(X) %*% y + 2 * new_rho * one_p)
constraints = list(Amat %*% target <= bmat,
Amat1 %*% target <= new_rho)
objective = Maximize(Amat1 %*% target)
problem = Problem(objective, constraints)
result = solve(problem)
z = result$getValue(target)[m+1, ]
new_lambda = result$getValue(target)[1:m, , drop=F]
# 새로운 rho, lambda에 대해 부등조건을 만족하지 않는(범위를 벗어나는) predictor를 찾는다
idx1 = which((-t(X) %*% y + new_rho * one_p) <= t(Aeq) %*% new_lambda)
idx2 = which((-t(X) %*% y - new_rho * one_p) >= t(Aeq) %*% new_lambda)
activeset = c(idx1, idx2)
sort(activeset) # 최종 active set
# 3. linear combination
activeset = c()
for(i in 1:m) {
idx1 = which(abs(((-t(X) %*% y + rho_min * one_p) - t(Aeq)[, -i, drop=F] %*%
lambda[-i, ,drop=F]) / t(Aeq)[, i] - lambda[i, ]) < 1e-4)
idx2 = which(abs(((-t(X) %*% y - rho_min * one_p) - t(Aeq)[, -i, drop=F] %*%
lambda[-i, ,drop=F]) / t(Aeq)[, i] - lambda[i, ]) < 1e-4)
# print(c(idx1, idx2))
# if(length(activeset) > 0) activeset = c(idx1, idx2)
# activeset = intersect(activeset, c(idx1, idx2))
activeset = union(activeset, c(idx1, idx2))
}
activeset
sort(activeset)
rm(list=ls())
gc()
set.seed(520)
if(!require("CVXR")) install.packages("CVXR")
library("CVXR")
# setting
n = 100
p = 5
m = 2
# data
X = matrix(rnorm(n*p), nrow = n)
X.m = apply(X, 2, mean)
X.m = matrix(X.m, nrow = n, ncol = p, byrow = T)
X = X - X.m
true_b = rep(1, p)
y = X %*% true_b + rnorm(n)
y = y - mean(y)
# constraints
# Aeq = matrix(sample(seq(-1, 2, by = 1), m * p, replace = T), nrow = m)
Aeq = matrix(sample(c(-2, -1, 1, 2), m * p, replace = T), nrow = m)
# Aeq = matrix(c(1,1,0,
# -1,0,1,
# -1,-1,1), nrow = m, byrow = T)
beq = matrix(rep(0, m), nrow = m)
# setting
zero_p = matrix(rep(0, p), ncol = 1)
zero_m = matrix(rep(0, m), ncol = 1)
zero_pm = matrix(rep(0, p*m), nrow = p)
zero_pp = matrix(rep(0, p*p), nrow = p)
one_p = matrix(rep(1, p), ncol = 1)
one_m = matrix(rep(1, m), ncol = 1)
I_p = matrix(diag(rep(1, p)), nrow = p)
# design matrix for Constraints
Aeq1 = matrix(c(1, t(zero_p), t(zero_m)), nrow = 1)
Aeq2 = rbind(c(0, t(zero_p), t(zero_m)),
cbind(zero_p, I_p, zero_pm),
c(0, t(zero_p), t(zero_m)))
Aeq3 = rbind(c(0, t(zero_p), t(zero_m)),
cbind(zero_p, zero_pp, t(Aeq)),
c(0, t(zero_p), t(zero_m)))
Aeq4 = rbind(0, -t(X)%*%y, 0)
Aeq5 = rbind(c(0, t(zero_p), t(zero_m)),
cbind(one_p, zero_pp, zero_pm),
c(0, t(zero_p), t(zero_m)))
# solve
target = Variable(1 + p + m)
constraints = list(Aeq2 %*% target == Aeq3 %*% target,
Aeq2 %*% target <= Aeq4 + Aeq5 %*% target,
Aeq2 %*% target >= Aeq4 - Aeq5 %*% target,
Aeq1 %*% target >= 0)
objective = Minimize(Aeq1 %*% target)
problem = Problem(objective, constraints)
result = solve(problem)
# result
target = result$getValue(target)
rho_min = target[1, ]
z = target[2:(1+p), ,drop=F]
lambda = target[(p+2):nrow(target), ,drop=F]
rho_min; z; lambda
t(Aeq)
idx1 = which(abs((-t(X) %*% y + rho_min * one_p) - t(Aeq) %*% lambda) <= 1e-4)
idx2 = which(abs((-t(X) %*% y - rho_min * one_p) - t(Aeq) %*% lambda) <= 1e-4)
activeset = union(idx1, idx2)
sort(activeset)
# plot
l1 = seq(-100, 200, length.out = 1000)
l2 = seq(-100, 200, length.out = 1000)
# rho_min = rho_min - 100
y_plus = function(l1, i) (-t(X) %*% y + rho_min * one_p)[i, ] / t(Aeq)[i ,2] - (l1 * t(Aeq)[i ,1]) / t(Aeq)[i ,2]
y_minus = function(l1, i) (-t(X) %*% y - rho_min * one_p)[i, ] / t(Aeq)[i ,2] - (l1 * t(Aeq)[i ,1]) / t(Aeq)[i ,2]
plot(l1, l2, ylab = "", type = "n", col = 1)
points(lambda[1, ], lambda[2, ], col = p+1)
for(i in 1:p) lines(l1, y_plus(l1, i), ylab = "", col = i)
for(i in 1:p) lines(l1, y_minus(l1, i), ylab = "", col = i)
rm(list=ls())
gc()
set.seed(520)
if(!require("CVXR")) install.packages("CVXR")
library("CVXR")
# setting
n = 200
p = 10
m = 5
# data
X = matrix(rnorm(n*p), nrow = n)
X.m = apply(X, 2, mean)
X.m = matrix(X.m, nrow = n, ncol = p, byrow = T)
X = X - X.m
true_b = rep(1, p)
y = X %*% true_b + rnorm(n)
y = y - mean(y)
# constraints
Aeq = matrix(sample(seq(-1, 2, by = 1), m * p, replace = T), nrow = m)
# Aeq = matrix(sample(c(-2, -1, 1, 2), m * p, replace = T), nrow = m)
# Aeq = matrix(c(1,1,0,
# -1,0,1,
# -1,-1,1), nrow = m, byrow = T)
beq = matrix(rep(0, m), nrow = m)
# setting
zero_p = matrix(rep(0, p), ncol = 1)
zero_m = matrix(rep(0, m), ncol = 1)
zero_pm = matrix(rep(0, p*m), nrow = p)
zero_pp = matrix(rep(0, p*p), nrow = p)
one_p = matrix(rep(1, p), ncol = 1)
one_m = matrix(rep(1, m), ncol = 1)
I_p = matrix(diag(rep(1, p)), nrow = p)
# design matrix for Constraints
Aeq1 = matrix(c(1, t(zero_p), t(zero_m)), nrow = 1)
Aeq2 = rbind(c(0, t(zero_p), t(zero_m)),
cbind(zero_p, I_p, zero_pm),
c(0, t(zero_p), t(zero_m)))
Aeq3 = rbind(c(0, t(zero_p), t(zero_m)),
cbind(zero_p, zero_pp, t(Aeq)),
c(0, t(zero_p), t(zero_m)))
Aeq4 = rbind(0, -t(X)%*%y, 0)
Aeq5 = rbind(c(0, t(zero_p), t(zero_m)),
cbind(one_p, zero_pp, zero_pm),
c(0, t(zero_p), t(zero_m)))
# solve
target = Variable(1 + p + m)
constraints = list(Aeq2 %*% target == Aeq3 %*% target,
Aeq2 %*% target <= Aeq4 + Aeq5 %*% target,
Aeq2 %*% target >= Aeq4 - Aeq5 %*% target,
Aeq1 %*% target >= 0)
objective = Minimize(Aeq1 %*% target)
problem = Problem(objective, constraints)
result = solve(problem)
# result
target = result$getValue(target)
rho_min = target[1, ]
z = target[2:(1+p), ,drop=F]
lambda = target[(p+2):nrow(target), ,drop=F]
rho_min; z; lambda
t(Aeq)
# rho_min에서는 모든 부등조건을 만족
idx1 = which((-t(X) %*% y + rho_min * one_p) <= t(Aeq) %*% lambda)
idx2 = which((-t(X) %*% y - rho_min * one_p) >= t(Aeq) %*% lambda)
activeset = c(idx1, idx2)
sort(activeset)
### 1. 이건 경계에 있는 predictor를 바로 activeset 지정 -> 이건 아닌듯!
idx1 = which(abs((-t(X) %*% y + rho_min * one_p) - t(Aeq) %*% lambda) <= 1e-4)
idx2 = which(abs((-t(X) %*% y - rho_min * one_p) - t(Aeq) %*% lambda) <= 1e-4)
activeset = union(idx1, idx2)
sort(activeset)
### 2. violation check
# find new_lambda corresponding to decreased rho(아주 작게 감소된 rho에 대해 violation을 새로 체크)
new_rho = rho_min - 1e-4 # rho is decreasing direction
target = Variable(1 + m)
Amat1 = matrix(c(rep(0, m), 1), nrow = 1)
Amat = rbind(cbind(t(Aeq), one_p), cbind(-t(Aeq), one_p))
bmat = rbind(-t(X) %*% y + 2 * new_rho * one_p, t(X) %*% y + 2 * new_rho * one_p)
constraints = list(Amat %*% target <= bmat,
Amat1 %*% target <= new_rho)
objective = Maximize(Amat1 %*% target)
problem = Problem(objective, constraints)
result = solve(problem)
z = result$getValue(target)[m+1, ]
new_lambda = result$getValue(target)[1:m, , drop=F]
# 새로운 rho, lambda에 대해 부등조건을 만족하지 않는(범위를 벗어나는) predictor를 찾는다
idx1 = which((-t(X) %*% y + new_rho * one_p) <= t(Aeq) %*% new_lambda)
idx2 = which((-t(X) %*% y - new_rho * one_p) >= t(Aeq) %*% new_lambda)
activeset = c(idx1, idx2)
sort(activeset) # 최종 active set
# 3. linear combination
activeset = c()
for(i in 1:m) {
idx1 = which(abs(((-t(X) %*% y + rho_min * one_p) - t(Aeq)[, -i, drop=F] %*%
lambda[-i, ,drop=F]) / t(Aeq)[, i] - lambda[i, ]) < 1e-4)
idx2 = which(abs(((-t(X) %*% y - rho_min * one_p) - t(Aeq)[, -i, drop=F] %*%
lambda[-i, ,drop=F]) / t(Aeq)[, i] - lambda[i, ]) < 1e-4)
# print(c(idx1, idx2))
# if(length(activeset) > 0) activeset = c(idx1, idx2)
# activeset = intersect(activeset, c(idx1, idx2))
activeset = union(activeset, c(idx1, idx2))
}
sort(activeset)
rm(list=ls())
gc()
set.seed(520)
if(!require("CVXR")) install.packages("CVXR")
library("CVXR")
# setting
n = 100
p = 5
m = 2
# data
X = matrix(rnorm(n*p), nrow = n)
X.m = apply(X, 2, mean)
X.m = matrix(X.m, nrow = n, ncol = p, byrow = T)
X = X - X.m
true_b = rep(1, p)
y = X %*% true_b + rnorm(n)
y = y - mean(y)
# constraints
# Aeq = matrix(sample(seq(-1, 2, by = 1), m * p, replace = T), nrow = m)
Aeq = matrix(sample(c(-2, -1, 1, 2), m * p, replace = T), nrow = m)
# Aeq = matrix(c(1,1,0,
# -1,0,1,
# -1,-1,1), nrow = m, byrow = T)
beq = matrix(rep(0, m), nrow = m)
# setting
zero_p = matrix(rep(0, p), ncol = 1)
zero_m = matrix(rep(0, m), ncol = 1)
zero_pm = matrix(rep(0, p*m), nrow = p)
zero_pp = matrix(rep(0, p*p), nrow = p)
one_p = matrix(rep(1, p), ncol = 1)
one_m = matrix(rep(1, m), ncol = 1)
I_p = matrix(diag(rep(1, p)), nrow = p)
# design matrix for Constraints
Aeq1 = matrix(c(1, t(zero_p), t(zero_m)), nrow = 1)
Aeq2 = rbind(c(0, t(zero_p), t(zero_m)),
cbind(zero_p, I_p, zero_pm),
c(0, t(zero_p), t(zero_m)))
Aeq3 = rbind(c(0, t(zero_p), t(zero_m)),
cbind(zero_p, zero_pp, t(Aeq)),
c(0, t(zero_p), t(zero_m)))
Aeq4 = rbind(0, -t(X)%*%y, 0)
Aeq5 = rbind(c(0, t(zero_p), t(zero_m)),
cbind(one_p, zero_pp, zero_pm),
c(0, t(zero_p), t(zero_m)))
# solve
target = Variable(1 + p + m)
constraints = list(Aeq2 %*% target == Aeq3 %*% target,
Aeq2 %*% target <= Aeq4 + Aeq5 %*% target,
Aeq2 %*% target >= Aeq4 - Aeq5 %*% target,
Aeq1 %*% target >= 0)
objective = Minimize(Aeq1 %*% target)
problem = Problem(objective, constraints)
result = solve(problem)
# result
target = result$getValue(target)
rho_min = target[1, ]
z = target[2:(1+p), ,drop=F]
lambda = target[(p+2):nrow(target), ,drop=F]
rho_min; z; lambda
t(Aeq)
idx1 = which(abs((-t(X) %*% y + rho_min * one_p) - t(Aeq) %*% lambda) <= 1e-4)
idx2 = which(abs((-t(X) %*% y - rho_min * one_p) - t(Aeq) %*% lambda) <= 1e-4)
activeset = union(idx1, idx2)
sort(activeset)
# plot
l1 = seq(-100, 200, length.out = 1000)
l2 = seq(-100, 200, length.out = 1000)
# rho_min = rho_min - 100
y_plus = function(l1, i) (-t(X) %*% y + rho_min * one_p)[i, ] / t(Aeq)[i ,2] - (l1 * t(Aeq)[i ,1]) / t(Aeq)[i ,2]
y_minus = function(l1, i) (-t(X) %*% y - rho_min * one_p)[i, ] / t(Aeq)[i ,2] - (l1 * t(Aeq)[i ,1]) / t(Aeq)[i ,2]
plot(l1, l2, ylab = "", type = "n", col = 1)
points(lambda[1, ], lambda[2, ], col = p+1)
for(i in 1:p) lines(l1, y_plus(l1, i), ylab = "", col = i)
for(i in 1:p) lines(l1, y_minus(l1, i), ylab = "", col = i)
rm(list = ls())
gc()
#
setwd("C:/Users/dpelt/OneDrive - 서울시립대학교/Documents/GitHub/ML_study/classo")
source("classopath_init.R")
source("classopath3.R")
if(!require("CVXR")) install.packages("CVXR")
library("CVXR")
# if(!require("cape")) install.packages("cape")
# library("cape")
#############################################################################
# Calculate the solution path of the constrained lasso problem that minimizes
# `0.5sumabs2(√obswt .* (y - X * β)) + ρ * sumabs(penwt .* β)`
# subject to linear constraints.
#############################################################################
set.seed(520)
# setting
n = 100
p = 10
m = 5
# data
X = matrix(rnorm(n*p), nrow = n)
X.m = apply(X, 2, mean)
X.m = matrix(X.m, nrow = n, ncol = p, byrow = T)
X = X - X.m
true_b = rep(1, p)
y = X %*% true_b + rnorm(n)
y = y - mean(y)
n = dim(X)[1]
p = dim(X)[2]
### equality constraints
# default
# Aeq = matrix(0, nrow = 0, ncol = dim(X)[2])
# beq = rep(0, dim(Aeq)[1])
# use
# Aeq = matrix(sample(seq(-1, 1, by = 1), m * p, replace = T), nrow = m)
Aeq = matrix(sample(c(1,2,0), m * p, replace = T), nrow = m)
# Aeq = matrix(rnorm(m*p, 1, 1), nrow = m)
# Aeq = matrix(c(1,1,1,0,0,0,1,1,1,0,
# -1,-1,-1,0,0,0,-1,-1,-1,0,
# 0,0,0,0,0,2,2,2,2,2), nrow = m, byrow = T)
# 0,0,0,0,0,-1,-1,-1,-1,-1,
# 1,1,1,1,1,1,1,1,1,1,
# 0,0,1,2,1,2,1,0,0,2,
# 0,0,2,4,2,4,2,0,0,4), nrow = m, byrow = T)
beq = matrix(rep(0, m), nrow = m)
### inequality constraints
# default
Aineq = matrix(0, nrow = 0, ncol = dim(X)[2])
bineq = rep(0, dim(Aineq)[1])
# use
# Aineq = -diag(rep(1, p))
# bineq = rep(0, p)
# penalty weight
penwt = rep(1, p) # 20-element Array{Frhoat64,1}
penidx = rep(T, p)
choose_one = F
# alrhocate variables arhong path
neq = dim(Aeq)[1]
nineq = dim(Aineq)[1]
maxiters = 5 * (p + nineq) # max number of path segments to consider
beta_path = matrix(rep(0, p * maxiters), nrow = p)
lambda_patheq = matrix(rep(0, neq * maxiters), nrow = neq) # dual variables for equality
mu_pathineq = matrix(rep(0, nineq * maxiters), nrow = nineq) # dual variables for inequality
rho_path = rep(0, maxiters) # tuning parameter
df_path = rep(Inf, maxiters) # degree of freedom
objval_path = rep(0, maxiters) # objective value
violation_path = rep(Inf, maxiters)
### initialization
H = t(X) %*% X
# find the maximum ρ (starting value)
l = init_path(X, y, Aeq, beq) # no inequality constraints
rho_path[1] = l$rho_max
lambda_patheq[, 1] = l$lambda_max
# subgradient for init_beta = 0
beta_path[, 1] = 0
resid = y - X %*% beta_path[, 1]
subgrad = - t(X) %*% resid - t(Aeq) %*% lambda_patheq[ ,1]
# choose candidates
# findDepMat(Aeq[, l$activeset])
Aeq[, l$activeset]
l$activeset
setB = c(1,2,3,5,9)
setB = l$activeset
# Matrix::rankMatrix(Aeq[, l$activeset])
Aeq[, setB]
Matrix::rankMatrix(Aeq[, setB]) == length(setB)
new_setActive = rep(F, p)
new_setActive[setB] = T
# derivative for beta and lambda
M = rbind(cbind(t(X[, new_setActive]) %*% X[, new_setActive], t(Aeq[, new_setActive])),
cbind(Aeq[, new_setActive], matrix(rep(0, neq * neq), nrow = neq)))
delta_beta_lambda = MASS::ginv(M) %*% rbind(subgrad[new_setActive, ,drop=F] / rho_path[1],
matrix(rep(0, neq), ncol = 1))
delta_beta = delta_beta_lambda[1:sum(new_setActive), ,drop=F]
delta_lambda = delta_beta_lambda[(sum(new_setActive)+1):nrow(delta_beta_lambda), ,drop=F]
#
t(X[, new_setActive]) %*% X[, new_setActive]
t(Aeq[, new_setActive]) %*% solve(diag(rep(.Machine$double.eps, neq))) %*% Aeq[, new_setActive]
t(X[, new_setActive]) %*% X[, new_setActive] -
t(Aeq[, new_setActive]) %*% solve(diag(rep(.Machine$double.eps, neq))) %*% Aeq[, new_setActive]
MASS::ginv(t(X[, new_setActive]) %*% X[, new_setActive] -
t(Aeq[, new_setActive]) %*% solve(diag(rep(.Machine$double.eps, neq))) %*% Aeq[, new_setActive])
MASS::ginv(t(X[, new_setActive]) %*% X[, new_setActive] -
t(Aeq[, new_setActive]) %*% solve(diag(rep(.Machine$double.eps, neq))) %*% Aeq[, new_setActive]) %*%
subgrad[new_setActive, ,drop=F] / rho_path[1]
new_setActive
MASS::ginv(t(X[, new_setActive]) %*% X[, new_setActive] -
t(Aeq[, new_setActive]) %*% solve(diag(rep(.Machine$double.eps, neq))) %*% Aeq[, new_setActive]) %*%
subgrad[new_setActive, ,drop=F] / rho_path[1]
X[, new_setActive]
delta_beta
MASS::ginv(t(X[, new_setActive]) %*% X[, new_setActive] -
t(Aeq[, new_setActive]) %*% solve(diag(rep(.Machine$double.eps, neq))) %*% Aeq[, new_setActive]) %*%
subgrad[new_setActive, ,drop=F] / rho_path[1]
# check constraints
abs(t(X[, !new_setActive]) %*% X[, new_setActive] %*% delta_beta +
t(Aeq[, !new_setActive]) %*% delta_lambda) <= matrix(rep(1, sum(!new_setActive)), ncol = 1)
delta_beta
setB = c(1,2,3,5,9)
# Matrix::rankMatrix(Aeq[, l$activeset])
Aeq[, setB]
Matrix::rankMatrix(Aeq[, setB]) == length(setB)
new_setActive = rep(F, p)
new_setActive[setB] = T
# derivative for beta and lambda
M = rbind(cbind(t(X[, new_setActive]) %*% X[, new_setActive], t(Aeq[, new_setActive])),
cbind(Aeq[, new_setActive], matrix(rep(0, neq * neq), nrow = neq)))
delta_beta_lambda = MASS::ginv(M) %*% rbind(subgrad[new_setActive, ,drop=F] / rho_path[1],
matrix(rep(0, neq), ncol = 1))
delta_beta = delta_beta_lambda[1:sum(new_setActive), ,drop=F]
delta_beta
