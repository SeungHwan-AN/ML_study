beq = matrix(rep(0, m), nrow = m)
# setting
zero_p = matrix(rep(0, p), ncol = 1)
zero_m = matrix(rep(0, m), ncol = 1)
zero_pm = matrix(rep(0, p*m), nrow = p)
zero_pp = matrix(rep(0, p*p), nrow = p)
one_p = matrix(rep(1, p), ncol = 1)
one_m = matrix(rep(1, m), ncol = 1)
I_p = matrix(diag(rep(1, p)), nrow = p)
# design matrix of Equality
Aeq1 = matrix(c(1, t(zero_p), t(zero_m)), nrow = 1)
Aeq2 = rbind(c(0, t(zero_p), t(zero_m)),
cbind(zero_p, I_p, zero_pm),
c(0, t(zero_p), t(zero_m)))
Aeq3 = rbind(c(0, t(zero_p), t(zero_m)),
cbind(zero_p, zero_pp, t(Aeq)),
c(0, t(zero_p), t(zero_m)))
Aeq4 = rbind(0, -t(X)%*%y, 0)
Aeq5 = rbind(c(0, t(zero_p), t(zero_m)),
cbind(one_p, zero_pp, zero_pm),
c(0, t(zero_p), t(zero_m)))
# solve
target = Variable(1 + p + m)
constraints = list(Aeq2 %*% target == Aeq3 %*% target,
Aeq2 %*% target <= Aeq4 + Aeq5 %*% target,
Aeq2 %*% target >= Aeq4 - Aeq5 %*% target,
Aeq1 %*% target >= 0)
objective = Minimize(Aeq1 %*% target)
problem = Problem(objective, constraints)
result = solve(problem)
# result
target = result$getValue(target)
rho_min = target[1, ]
z = target[2:(1+p), ,drop=F]
lambda = target[(p+2):nrow(target), ,drop=F]
rho_min; z; lambda
Aeq
# check
sum(abs(z - t(Aeq) %*% lambda)) < 1e-6
# violation check : rho is decreasing
t(Aeq) %*% lambda
((-t(X) %*% y + rho_min) - (t(Aeq) %*% lambda)) < 1e-8
which.min((-t(X) %*% y + rho_min) - (t(Aeq) %*% lambda))
# maximum of lowerbound
-t(X) %*% y + rho_min
-t(X) %*% y - rho_min
min(-t(X) %*% y + rho_min)
max(-t(X) %*% y - rho_min)
t(Aeq) %*% lambda
t(Aeq[, 1]) %*% lambda
# violation check
max.j = which.max(-t(X) %*% y - rho_min) # maximum of lowerbound
min.j = which.min(-t(X) %*% y + rho_min) # minimum of upperbound
rm(list=ls())
gc()
set.seed(520)
if(!require("CVXR")) install.packages("CVXR")
library("CVXR")
# setting
n = 100
p = 10
m = 2
# data
X = matrix(rnorm(n*p), nrow = n)
X.m = apply(X, 2, mean)
X.m = matrix(X.m, nrow = n, ncol = p, byrow = T)
X = X - X.m
true_b = rep(1, p)
y = X %*% true_b + rnorm(n)
y = y - mean(y)
# constraints
Aeq = matrix(sample(seq(-1, 2, by = 1), m * p, replace = T), nrow = m)
Aeq
rm(list=ls())
gc()
set.seed(520)
if(!require("CVXR")) install.packages("CVXR")
library("CVXR")
# setting
n = 100
p = 10
m = 2
# data
X = matrix(rnorm(n*p), nrow = n)
X.m = apply(X, 2, mean)
X.m = matrix(X.m, nrow = n, ncol = p, byrow = T)
X = X - X.m
true_b = rep(1, p)
y = X %*% true_b + rnorm(n)
y = y - mean(y)
# constraints
Aeq = matrix(sample(seq(-1, 2, by = 1), m * p, replace = T), nrow = m)
# Aeq = matrix(c(1,1,0,
# -1,0,1,
# -1,-1,1), nrow = m, byrow = T)
beq = matrix(rep(0, m), nrow = m)
# setting
zero_p = matrix(rep(0, p), ncol = 1)
zero_m = matrix(rep(0, m), ncol = 1)
zero_pm = matrix(rep(0, p*m), nrow = p)
zero_pp = matrix(rep(0, p*p), nrow = p)
one_p = matrix(rep(1, p), ncol = 1)
one_m = matrix(rep(1, m), ncol = 1)
I_p = matrix(diag(rep(1, p)), nrow = p)
# design matrix of Equality
Aeq1 = matrix(c(1, t(zero_p), t(zero_m)), nrow = 1)
Aeq2 = rbind(c(0, t(zero_p), t(zero_m)),
cbind(zero_p, I_p, zero_pm),
c(0, t(zero_p), t(zero_m)))
Aeq3 = rbind(c(0, t(zero_p), t(zero_m)),
cbind(zero_p, zero_pp, t(Aeq)),
c(0, t(zero_p), t(zero_m)))
Aeq4 = rbind(0, -t(X)%*%y, 0)
Aeq5 = rbind(c(0, t(zero_p), t(zero_m)),
cbind(one_p, zero_pp, zero_pm),
c(0, t(zero_p), t(zero_m)))
# solve
target = Variable(1 + p + m)
constraints = list(Aeq2 %*% target == Aeq3 %*% target,
Aeq2 %*% target <= Aeq4 + Aeq5 %*% target,
Aeq2 %*% target >= Aeq4 - Aeq5 %*% target,
Aeq1 %*% target >= 0)
objective = Minimize(Aeq1 %*% target)
problem = Problem(objective, constraints)
result = solve(problem)
# result
target = result$getValue(target)
rho_min = target[1, ]
z = target[2:(1+p), ,drop=F]
lambda = target[(p+2):nrow(target), ,drop=F]
rho_min; z; lambda
Aeq
# check
sum(abs(z - t(Aeq) %*% lambda)) < 1e-6
# violation check : rho is decreasing
t(Aeq) %*% lambda
((-t(X) %*% y + rho_min) - (t(Aeq) %*% lambda)) < 1e-8
which.min((-t(X) %*% y + rho_min) - (t(Aeq) %*% lambda))
# maximum of lowerbound
-t(X) %*% y + rho_min
-t(X) %*% y - rho_min
min(-t(X) %*% y + rho_min)
max(-t(X) %*% y - rho_min)
t(Aeq) %*% lambda
t(Aeq[, 1]) %*% lambda
# init activeset?
max.j = which.max(-t(X) %*% y - rho_min) # maximum of lowerbound
min.j = which.min(-t(X) %*% y + rho_min) # minimum of upperbound
-t(X) %*% y + rho_min
-t(X) %*% y - rho_min
rm(list=ls())
gc()
set.seed(520)
if(!require("CVXR")) install.packages("CVXR")
library("CVXR")
# setting
n = 100
p = 10
m = 5
# data
X = matrix(rnorm(n*p), nrow = n)
X.m = apply(X, 2, mean)
X.m = matrix(X.m, nrow = n, ncol = p, byrow = T)
X = X - X.m
true_b = rep(1, p)
y = X %*% true_b + rnorm(n)
y = y - mean(y)
# constraints
Aeq = matrix(sample(seq(-1, 2, by = 1), m * p, replace = T), nrow = m)
# Aeq = matrix(c(1,1,0,
# -1,0,1,
# -1,-1,1), nrow = m, byrow = T)
beq = matrix(rep(0, m), nrow = m)
# setting
zero_p = matrix(rep(0, p), ncol = 1)
zero_m = matrix(rep(0, m), ncol = 1)
zero_pm = matrix(rep(0, p*m), nrow = p)
zero_pp = matrix(rep(0, p*p), nrow = p)
one_p = matrix(rep(1, p), ncol = 1)
one_m = matrix(rep(1, m), ncol = 1)
I_p = matrix(diag(rep(1, p)), nrow = p)
# design matrix of Equality
Aeq1 = matrix(c(1, t(zero_p), t(zero_m)), nrow = 1)
Aeq2 = rbind(c(0, t(zero_p), t(zero_m)),
cbind(zero_p, I_p, zero_pm),
c(0, t(zero_p), t(zero_m)))
Aeq3 = rbind(c(0, t(zero_p), t(zero_m)),
cbind(zero_p, zero_pp, t(Aeq)),
c(0, t(zero_p), t(zero_m)))
Aeq4 = rbind(0, -t(X)%*%y, 0)
Aeq5 = rbind(c(0, t(zero_p), t(zero_m)),
cbind(one_p, zero_pp, zero_pm),
c(0, t(zero_p), t(zero_m)))
# solve
target = Variable(1 + p + m)
constraints = list(Aeq2 %*% target == Aeq3 %*% target,
Aeq2 %*% target <= Aeq4 + Aeq5 %*% target,
Aeq2 %*% target >= Aeq4 - Aeq5 %*% target,
Aeq1 %*% target >= 0)
objective = Minimize(Aeq1 %*% target)
problem = Problem(objective, constraints)
result = solve(problem)
# result
target = result$getValue(target)
rho_min = target[1, ]
z = target[2:(1+p), ,drop=F]
lambda = target[(p+2):nrow(target), ,drop=F]
rho_min; z; lambda
Aeq
# check
sum(abs(z - t(Aeq) %*% lambda)) < 1e-6
# violation check : rho is decreasing
t(Aeq) %*% lambda
((-t(X) %*% y + rho_min) - (t(Aeq) %*% lambda)) < 1e-8
which.min((-t(X) %*% y + rho_min) - (t(Aeq) %*% lambda))
# maximum of lowerbound
-t(X) %*% y + rho_min
-t(X) %*% y - rho_min
min(-t(X) %*% y + rho_min)
max(-t(X) %*% y - rho_min)
t(Aeq) %*% lambda
t(Aeq[, 1]) %*% lambda
# init activeset?
max.j = which.max(-t(X) %*% y - rho_min) # maximum of lowerbound
min.j = which.min(-t(X) %*% y + rho_min) # minimum of upperbound
### inequality constraints
# default
Aineq = matrix(0, nrow = 0, ncol = dim(X)[2])
bineq = rep(0, dim(Aineq)[1])
# penalty weight
penwt = rep(1, p) # 20-element Array{Frhoat64,1}
X
n = dim(X)[1]
p = dim(X)[2]
rho_ridge = 0
penwt = rep(1, p)
penidx = rep(T, p)
neq = dim(Aeq)[1]
nineq = dim(Aineq)[1]
maxiters = 5 * (p + nineq) # max number of path segments to consider
beta_path = matrix(rep(0, p * maxiters), nrow = p)
lambda_patheq = matrix(rep(0, neq * maxiters), nrow = neq) # dual variables for equality
mu_pathineq = matrix(rep(0, nineq * maxiters), nrow = nineq) # dual variables for inequality
rho_path = rep(0, maxiters) # tuning parameter
df_path = rep(Inf, maxiters) # degree of freedom
objval_path = rep(0, maxiters) # objective value
violation_path = rep(Inf, maxiters)
### initialization
# use LP to find ρmax
H = t(X) %*% X
rho_path[1] = rho_min
idx = c(max.j, min.j)
# calculate at ρmax
l = constrsparsereg(X, y, Aeq, beq, Aineq, bineq,
rho = rho_path[1], penwt = penidx)
#
setwd("C:/Users/dpelt/OneDrive - 서울시립대학교/Documents/GitHub/ML_study/classo")
source("find_rho_max.R")
source("constrsparsereg.R")
source("classopath.R")
# calculate at ρmax
l = constrsparsereg(X, y, Aeq, beq, Aineq, bineq,
rho = rho_path[1], penwt = penidx)
beta_path[, 1] = l$beta_value
objval_path[1] = l$problem.optval
problem = l$problem
result = l$result
beta_path
for(i in 1:min(2, length(problem@constraints))) {
if(canonicalize(problem@constraints[[i]])[[2]][[1]]$class == "LinEqConstr") {
lambda_patheq[, 1] = result$getDualValue(problem@constraints[[i]]) # 이거 값 다름 - 왜 0 나오지?***** (부호변경)
} else if(canonicalize(problem@constraints[[i]])[[2]][[1]]$class == "LinLeqConstr") {
mu_pathineq[, 1] = result$getDualValue(problem@constraints[[i]])
}
}
lambda_patheq
mu_pathineq
lambda
lambda_patheq[, 1] = lambda
objval_path
#???
mu_pathineq[mu_pathineq < 0] = 0
setActive = (abs(beta_path[, 1]) > 1e-4) | (!penidx)
setActive
setActive = c(T,T,F,F,F,F,F,F,F,F)
beta_path[!setActive, 1] = 0
beta_path
residIneq = Aineq %*% beta_path[, 1] - bineq
setIneqBorder = residIneq == 0
nIneqBorder = sum(setIneqBorder != 0)
residIneq
# initialize subgradient vector (stationarity condition)
resid = y - X %*% beta_path[, 1]
if(neq > 0 & nineq > 0) {
subgrad = t(X) %*% resid - t(Aeq) %*% lambda_patheq[ ,1] - t(Aineq) %*% mu_pathineq[, 1]
} else if(neq > 0 & nineq == 0) {
subgrad = t(X) %*% resid - t(Aeq) %*% lambda_patheq[ ,1]
} else if(neq == 0 & nineq > 0) {
subgrad = t(X) %*% resid - t(Aineq) %*% mu_pathineq[, 1]
}
# subgradient of beta
subgrad[setActive] = sign(beta_path[setActive, 1])
subgrad[!setActive] = subgrad[!setActive] / rho_path[1]
idx
rm(list=ls())
gc()
set.seed(520)
if(!require("CVXR")) install.packages("CVXR")
library("CVXR")
# setting
n = 100
p = 10
m = 2
# data
X = matrix(rnorm(n*p), nrow = n)
X.m = apply(X, 2, mean)
X.m = matrix(X.m, nrow = n, ncol = p, byrow = T)
X = X - X.m
true_b = rep(1, p)
y = X %*% true_b + rnorm(n)
y = y - mean(y)
# constraints
Aeq = matrix(sample(seq(-1, 2, by = 1), m * p, replace = T), nrow = m)
# Aeq = matrix(c(1,1,0,
# -1,0,1,
# -1,-1,1), nrow = m, byrow = T)
beq = matrix(rep(0, m), nrow = m)
# setting
zero_p = matrix(rep(0, p), ncol = 1)
zero_m = matrix(rep(0, m), ncol = 1)
zero_pm = matrix(rep(0, p*m), nrow = p)
zero_pp = matrix(rep(0, p*p), nrow = p)
one_p = matrix(rep(1, p), ncol = 1)
one_m = matrix(rep(1, m), ncol = 1)
I_p = matrix(diag(rep(1, p)), nrow = p)
# design matrix of Equality
Aeq1 = matrix(c(1, t(zero_p), t(zero_m)), nrow = 1)
Aeq2 = rbind(c(0, t(zero_p), t(zero_m)),
cbind(zero_p, I_p, zero_pm),
c(0, t(zero_p), t(zero_m)))
Aeq3 = rbind(c(0, t(zero_p), t(zero_m)),
cbind(zero_p, zero_pp, t(Aeq)),
c(0, t(zero_p), t(zero_m)))
Aeq4 = rbind(0, -t(X)%*%y, 0)
Aeq5 = rbind(c(0, t(zero_p), t(zero_m)),
cbind(one_p, zero_pp, zero_pm),
c(0, t(zero_p), t(zero_m)))
# solve
target = Variable(1 + p + m)
constraints = list(Aeq2 %*% target == Aeq3 %*% target,
Aeq2 %*% target <= Aeq4 + Aeq5 %*% target,
Aeq2 %*% target >= Aeq4 - Aeq5 %*% target,
Aeq1 %*% target >= 0)
objective = Minimize(Aeq1 %*% target)
problem = Problem(objective, constraints)
result = solve(problem)
# result
target = result$getValue(target)
rho_min = target[1, ]
z = target[2:(1+p), ,drop=F]
lambda = target[(p+2):nrow(target), ,drop=F]
rho_min; z; lambda
Aeq
# check
sum(abs(z - t(Aeq) %*% lambda)) < 1e-6
# violation check : rho is decreasing
t(Aeq) %*% lambda
((-t(X) %*% y + rho_min) - (t(Aeq) %*% lambda)) < 1e-8
which.min((-t(X) %*% y + rho_min) - (t(Aeq) %*% lambda))
# maximum of lowerbound
-t(X) %*% y + rho_min
-t(X) %*% y - rho_min
min(-t(X) %*% y + rho_min)
max(-t(X) %*% y - rho_min)
t(Aeq) %*% lambda
t(Aeq[, 1]) %*% lambda
# init activeset?
max.j = which.max(-t(X) %*% y - rho_min) # maximum of lowerbound
min.j = which.min(-t(X) %*% y + rho_min) # minimum of upperbound
-t(X) %*% y + rho_min
-t(X) %*% y - rho_min
# plot
l1 = seq(-300, 100)
l1
# plot
l1 = seq(-300, 100, length.out = 1000000)
l1
# plot
l1 = seq(-100, 100, length.out = 1000)
l2 = seq(-100, 100, length.out = 1000)
t(Aeq[, 1])[1]
t(Aeq[, 1])[2]
t(Aeq[, 1])[3]
plot(t(Aeq[, 1])[1] * l1 + t(Aeq[, 1])[2] * l2)
plot(t(Aeq[, 1])[1] * l1 + t(Aeq[, 1])[2] * l2, ylab = "", xlab = "")
plot(l1, t(Aeq[, 1])[1] * l1 + t(Aeq[, 1])[2] * l2, ylab = "", xlab = "")
t(Aeq[, 1])[1]
t(Aeq[, 1])
plot(l1, t(Aeq[, 1])[1] * l1 + t(Aeq[, 1])[2] * l2, ylab = "", xlab = "", col = 2)
for(i in 2:p) lines(l1, t(Aeq[, i])[1] * l1 + t(Aeq[, i])[2] * l2, ylab = "", xlab = "", col = 1)
plot(l1, t(Aeq[, 1])[1] * l1 + t(Aeq[, 1])[2] * l2, ylab = "", xlab = "", col = 1, lwd = 1)
for(i in 2:p) lines(l1, t(Aeq[, i])[1] * l1 + t(Aeq[, i])[2] * l2, ylab = "", xlab = "", col = 2, lwd = 1)
plot(l1, t(Aeq[, 1])[1] * l1 + t(Aeq[, 1])[2] * l2, ylab = "", xlab = "", col = 1, lwd = 1)
for(i in 2:p) lines(l1, t(Aeq[, i])[1] * l1 + t(Aeq[, i])[2] * l2, ylab = "", xlab = "", col = 2, lwd = i)
plot(l1, t(Aeq[, 1])[1] * l1 + t(Aeq[, 1])[2] * l2, ylab = "", xlab = "", col = 1, lwd = 1)
for(i in 2:p) lines(l1, t(Aeq[, i])[1] * l1 + t(Aeq[, i])[2] * l2, ylab = "", xlab = "", col = i, lwd = 1)
line(l1, t(Aeq[, 1])[1] * l1 + t(Aeq[, 1])[2] * l2, ylab = "", xlab = "", col = 1, lwd = 1)
line(l1, t(Aeq[, 1])[1] * l1 + t(Aeq[, 1])[2] * l2, ylab = "", xlab = "", col = 1, lwd = 1, type = 'l')
plot(l1, t(Aeq[, 1])[1] * l1 + t(Aeq[, 1])[2] * l2, ylab = "", xlab = "", col = 1, lwd = 1, type = 'l')
for(i in 2:p) lines(l1, t(Aeq[, i])[1] * l1 + t(Aeq[, i])[2] * l2, ylab = "", xlab = "", col = i, lwd = 1)
plot(l1, l2, ylab = "", xlab = "")
plot(l1, l2, ylab = "", xlab = "", type = "n")
for(i in 1:p) polygon(t(Aeq[, i])[1] * l1 + t(Aeq[, i])[2] * l2 <= (-t(X) %*% y + rho_min)[1, ])
plot(l1, l2, ylab = "", xlab = "", type = "n")
for(i in 1:p) polygon(t(Aeq[, i])[1] * l1 + t(Aeq[, i])[2] * l2 <= (-t(X) %*% y + rho_min)[1, ],
t(Aeq[, i])[1] * l1 + t(Aeq[, i])[2] * l2 >= (-t(X) %*% y - rho_min)[1, ])
for(i in 1:p) polygon(t(Aeq[, i])[1] * l1 + t(Aeq[, i])[2] * l2 <= (-t(X) %*% y + rho_min)[1, ])
plot(l1, l2, ylab = "", xlab = "", type = "n")
for(i in 1:p) plot(t(Aeq[, i])[1] * l1 + t(Aeq[, i])[2] * l2 <= (-t(X) %*% y + rho_min)[1, ],
t(Aeq[, i])[1] * l1 + t(Aeq[, i])[2] * l2 >= (-t(X) %*% y - rho_min)[1, ])
x = seq(-4,4,length=81)
fun = (x^2 -3)
sol = ((x^2 -3) * (x^2 > 3))
plot(x,fun, type="l", ylab=expression(x^2 - 3))
lines(x, sol)
polygon(c(-4,x,4), c(0,sol,0), col= "gray", border=NA)
abline(h=0, v=0)
plot(l1, l2, ylab = "", xlab = "", type = "n")
for(i in 1:p) polygon((-t(X) %*% y + rho_min)[1, ], (-t(X) %*% y - rho_min)[1, ])
for(i in 1:p) polygon((-t(X) %*% y - rho_min)[i, ], (-t(X) %*% y + rho_min)[i, ])
plot(l1, l2, ylab = "", xlab = "", type = "n")
for(i in 1:p) polygon((-t(X) %*% y - rho_min)[i, ], (-t(X) %*% y + rho_min)[i, ])
polygon((-t(X) %*% y - rho_min), (-t(X) %*% y + rho_min))
polygon((-t(X) %*% y - rho_min), (-t(X) %*% y + rho_min))
(-t(X) %*% y - rho_min)
abline((-t(X) %*% y - rho_min), (-t(X) %*% y + rho_min))
plot((-t(X) %*% y - rho_min), (-t(X) %*% y + rho_min), type = "h")
abline((-t(X) %*% y - rho_min), (-t(X) %*% y + rho_min))
plot(l1, l2, ylab = "", xlab = "", type = "n")
abline((-t(X) %*% y - rho_min), (-t(X) %*% y + rho_min))
plot(l1, l2, ylab = "", xlab = "", type = "n")
abline(cbind((-t(X) %*% y - rho_min), (-t(X) %*% y + rho_min)),
cbind((-t(X) %*% y - rho_min), (-t(X) %*% y + rho_min)))
cbind((-t(X) %*% y - rho_min), (-t(X) %*% y + rho_min))
abline(cbind((-t(X) %*% y - rho_min), (-t(X) %*% y + rho_min)))
plot(cbind((-t(X) %*% y - rho_min), (-t(X) %*% y + rho_min)),
cbind((-t(X) %*% y - rho_min), (-t(X) %*% y + rho_min)))
plot(l1, l2, ylab = "", xlab = "", type = "n")
polygon(cbind((-t(X) %*% y - rho_min), (-t(X) %*% y + rho_min)),
cbind((-t(X) %*% y - rho_min), (-t(X) %*% y + rho_min)))
# plot
l1 = seq(-500, 100, length.out = 10000)
l2 = seq(-500, 100, length.out = 10000)
plot(l1, l2, ylab = "", xlab = "", type = "n")
abline(cbind((-t(X) %*% y - rho_min), (-t(X) %*% y + rho_min)),
cbind((-t(X) %*% y - rho_min), (-t(X) %*% y + rho_min)))
cbind((-t(X) %*% y - rho_min), (-t(X) %*% y + rho_min))
?abline
plot(l1, l2, ylab = "", xlab = "", type = "n")
abline(v = cbind((-t(X) %*% y - rho_min), (-t(X) %*% y + rho_min)),
cbind((-t(X) %*% y - rho_min), (-t(X) %*% y + rho_min)))
plot(l1, l2, ylab = "", xlab = "", type = "n")
abline(v = (-t(X) %*% y - rho_min))
abline(v = (-t(X) %*% y + rho_min))
plot(l1, l2, ylab = "", xlab = "", type = "n")
abline(v = (-t(X) %*% y - rho_min))
abline(v = (-t(X) %*% y + rho_min))
abline(h = (-t(X) %*% y - rho_min))
abline(h = (-t(X) %*% y + rho_min))
# plot
l1 = seq(-300, 100, length.out = 10000)
l2 = seq(-300, 100, length.out = 10000)
plot(l1, l2, ylab = "", xlab = "", type = "n")
abline(v = (-t(X) %*% y - rho_min))
abline(v = (-t(X) %*% y + rho_min))
abline(h = (-t(X) %*% y - rho_min))
abline(h = (-t(X) %*% y + rho_min))
plot(l1, l2, ylab = "", xlab = "", type = "n")
abline(v = max(-t(X) %*% y - rho_min), h = max(-t(X) %*% y - rho_min))
abline(v = min(-t(X) %*% y + rho_min), h = min(-t(X) %*% y + rho_min))
for(i in 1:p) lines(l1, t(Aeq[, i])[1] * l1 + t(Aeq[, i])[2] * l2, ylab = "", xlab = "", col = i, lwd = 1)
plot(l1, l2, ylab = "", xlab = "", type = "n")
abline(v = (-t(X) %*% y - rho_min))
abline(v = (-t(X) %*% y + rho_min))
abline(h = (-t(X) %*% y - rho_min))
abline(h = (-t(X) %*% y + rho_min))
for(i in 1:p) lines(l1, t(Aeq[, i])[1] * l1 + t(Aeq[, i])[2] * l2, ylab = "", xlab = "", col = i, lwd = 1)
i = 1
plot(l1, l2, ylab = "", xlab = "", type = "n")
abline(v = (-t(X) %*% y - rho_min)[i, ], h = (-t(X) %*% y - rho_min)[i, ])
abline(v = (-t(X) %*% y + rho_min[i, ]), h = (-t(X) %*% y + rho_min)[i, ])
abline(v = (-t(X) %*% y + rho_min)[i, ], h = (-t(X) %*% y + rho_min)[i, ])
for(i in 1:p) lines(l1, t(Aeq[, i])[1] * l1 + t(Aeq[, i])[2] * l2, ylab = "", xlab = "", col = i, lwd = 1)
i = 1
plot(l1, l2, ylab = "", xlab = "", type = "n")
abline(v = (-t(X) %*% y - rho_min)[i, ], h = (-t(X) %*% y - rho_min)[i, ])
abline(v = (-t(X) %*% y + rho_min)[i, ], h = (-t(X) %*% y + rho_min)[i, ])
lines(l1, t(Aeq[, i])[1] * l1 + t(Aeq[, i])[2] * l2, ylab = "", xlab = "", col = i, lwd = 1)
plot(l1, l2, ylab = "", xlab = "", type = "n")
for(i in 1:p) {
abline(v = (-t(X) %*% y - rho_min)[i, ], h = (-t(X) %*% y - rho_min)[i, ], col = i)
abline(v = (-t(X) %*% y + rho_min)[i, ], h = (-t(X) %*% y + rho_min)[i, ], col = i)
lines(l1, t(Aeq[, i])[1] * l1 + t(Aeq[, i])[2] * l2, ylab = "", xlab = "", col = i, lwd = 1)
}
plot(l1, l2, ylab = "", xlab = "", type = "n")
abline(v = max(-t(X) %*% y - rho_min), h = max(-t(X) %*% y - rho_min))
abline(v = min(-t(X) %*% y + rho_min), h = min(-t(X) %*% y + rho_min))
for(i in c(max.j, min.j)) lines(l1, t(Aeq[, i])[1] * l1 + t(Aeq[, i])[2] * l2, ylab = "", xlab = "", col = i, lwd = 1)
plot(l1, l2, ylab = "", xlab = "", type = "n")
abline(v = max(-t(X) %*% y - rho_min), h = max(-t(X) %*% y - rho_min))
abline(v = min(-t(X) %*% y + rho_min), h = min(-t(X) %*% y + rho_min))
for(i in 1:p) lines(l1, t(Aeq[, i])[1] * l1 + t(Aeq[, i])[2] * l2, ylab = "", xlab = "", col = i, lwd = 1)
